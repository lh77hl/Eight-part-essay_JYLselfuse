# MySQL

## 基础篇

### 一、执行一条select语句期间发生了什么？

1 MySQL的基本架构和功能是什么？

答：MySQL的架构共分两层：**Sever层**，负责建立连接、分析以及执行SQL；**存储引擎层**，负责数据的存储和提取。

其中Sever层实现MySQL大部分的核心功能模块，包括**连接器、查询缓存、解析器、预处理器、优化器、执行器**等。所有的**内置函数**(日期、时间、数学、加密函数等)、所有的**跨存储引擎功能**(存储过程、触发器、视图等)也是在这一层实现。

存储引擎层支持不同的存储引擎，他们可以共用一个Sever层。现在InnoDB是默认的存储引擎，默认使用B+树索引类型。

2 **第一步：连接器→连接客户端与MySQL服务器的第一道网关，本身不执行语句，仅仅管控连接**

**功能**-接收客户端请求；建立TCP连接或本地套接字连接；验证用户名密码是否正确；检查用户是否有权限访问数据库

**具体工作流程**-**建立连接**，根据输入的主机地址选择连接方式，使用TCP握手连接；**进行身份认证**，服务端发送随机字符串，客户端加密后返给服务端，服务端进一步验证加密结果是否正确；**校验权限**，登录成功后，由连接器查询数据库的user表判断客户端是否有权限访问或执行特定语句，并保存权限便于此连接后续任何操作都基于这个权限逻辑进行判断。【如果管理员在连接途中修改了用户权限，当前连接的操作是不影响的，只有下一次连接时才会用新的权限设置】

拓展-连接池可以复用连接避免每次连接带来的开销；MySQL支持TCP层的Keep-Alive ，或应用层用连接池实现“长连接”。

【如何查看MySQL服务被多少客户端连接？】

答：执行**show processlist**命令可以查看。

对处于休眠状态的用户，其连接的最大空闲时长由**wait_timeout**参数控制，默认8小时，超过这个时间就会自动断开。也可以通过**kill connection + id**的命令手动断开空闲连接。

其支持的最大连接数，由**max_connections**参数控制，超过时系统会拒绝后面的连接请求。

【MySQL使用长连接时临时使用内存管理连接对象，可能导致占用内存增多而被系统强制kill发生异常重启现象，怎么解决呢？】

答：**定期断开长连接**，释放连接占用的内存资源；或**客户端主动重置连接**，调用mysql_reset_connection函数重置连接，释放内存但不断开连接。

3 **第二步：查询缓存→加速相同SQL重复查询的机制**，发生在解析和执行之前，MySQL8.0已移除Sever层的该特性

**基本原理**-**检查缓存是否启用**，通过判断query_cache_type[=demand就表示关闭这个功能]/size，若未启用则直接跳过这个阶段；**生成查询缓存键**，根据整个SQL语句的文本(包括空格和大小写)计算query cache key；**查询匹配结果**，通过计算好的key去缓存中比对是否有完全一致的记录；如果匹配，且相关表未再发生过写入操作(INSERT/UPDATE/DELETE)，则直接把缓存结果返回，不再走优化器和执行器；反之如果查找失败，或相关表被修改、老旧数据被清除，则正常走优化器、执行器等，并把这次查询和查询结果缓存。

**局限性**-**匹配机制严格**，不适配动态生成的SQL；**缓存失效频繁**，一旦查询涉及的表被修改缓存就失效，对写操作频繁的场景几乎不适用；**并发争用严重**，多线程读写缓存时存在锁竞争。

适用场景-静态数据、重复数据、表更新少查询场景

4 **第三步：解析器→将用户提交的SQL语句进行词法和语法分析，即解析SQL语句转化为数据库可以理解的结构**，是查询处理流程的重要阶段

**工作流程**-**词法分析**，把SQL语句拆分成单个token，包括关键字、字段名、常量以及运算符等；**语法分析**，检查SQL语句是否符合语法规则，并生成语法树。

**输出结果**-**抽象语法树(AST)和内部表示结构**，传递给下面的优化器做进一步处理。

5 **第四步：预处理器、优化器、执行器→验证SQL的语义是否正确并执行SQL**

**①预处理器(prepare)：进行语义分析**。验证语义是否正确，包括要查询的表、字段等是否存在，字段和表之间是否匹配，以及类型是否兼容等。

**②优化器(optimize)：确定SQL查询语句的执行方案**。在多个可行的执行计划中，优化器可以考虑成本决定选择代价最低的。可以通过explain命令查询某语句的执行计划。通过代价模型的估算[根据统计信息，如查询行数、唯一值的个数、索引的选择度等]，确定访问路径[全表or索引]、连接顺序来选择连接算法。【总结来说，如果一个查询可以通过二级索引就直接拿到所有需要的字段，就是所谓的“覆盖索引”，此时优化器就不再需要“先二级索引找到主键，再用主键查整行数据”的**回表**方式进行查询。反之，如果查询字段不在二级索引里，比如过滤条件是name，但是要查询name对应的email，就需要先通过二级索引定位到主键——id，再根据这个id主键索引到整行数据，进而取出email字段对应的value】

【补充知识-在InnoDB存储引擎中，**主键索引B+树的叶子节点存储整行数据，二级索引B+树的叶子节点存储对应行的主键值而不是整行数据**】

**③执行器(execute)：按照优化器给出的“执行计划”一步步执行模块。**执行过程中，执行器和存储引擎交互，以记录为单位。下面是三种不同的执行方式。

**主键索引查询**-访问类型为const，**调用read_first_record函数指向存储引擎<u>索引查询的接口</u>**，令其根据查询条件定位符合的第一条记录→**存储引擎**根据主键索引的B+树结构**定位符合条件的第一条记录**，若记录不存在则报错并结束查询，若记录存在则将其返回给执行器→**执行器**获得记录后**进一步判断是否符合查询条件**，若不符合则跳过这条记录，若符合则返给客户端→基于while循环再次调用read_record函数指向**-1**，令**执行器退出循环**，结束查询。

**全表扫描**-访问类型为all，**调用read_first_record 函数指向存储引擎<u>全扫描的接口</u>**，令其读取表中的第一条记录→**执行器逐一判断所读记录是否符合过滤条件**，若不是则跳过，若是则将记录返给客户端→基于while循环再次调用read_record函数指向**全扫描接口**，**继续扫描下一条记录**→直到存储引擎读完表中所有记录向执行器返回读取完毕的信息→执行器收到信息退出循环停止查询。

**索引下推**[减少二级索引在查询时的回表操作]-Server层调用存储引擎的接口定位满足查询条件的第一条二级索引记录→存储引擎定位到后，先不执行回表，而是先判断该索引中包含的其他列条件是否成立[直接在索引阶段筛掉不符合其他列条件的数据，而不是存储引擎把所有符合第一个条件的记录都找出来用主键回表取出一条条整行数据，再一个个让Server层自己比对其他列条件满不满足]，若不成立则直接跳过该二级索引，若成立再执行回表操作，把完整记录返给Sever层→Server层进一步判断其他查询条件是否成立，若不成立则跳过继续向存储引擎要下一条记录，若成立则返给客户端→直到存储引擎把表中所有记录读完。【但该种方式的前提条件是要查询的字段在二级索引的叶子节点可以拿到，或者和二级索引建立了复合索引】【总的来说，索引下推把原本需要Server层判断的条件提前下放到存储引擎层判断】

【总结一下总流程就是：先根据不同的索引类型调用函数指向存储引擎的接口[索引查询/全扫描]；1>索引查询的话就是存储引擎先定位符合条件的记录再让执行器进一步判断一下2>全表扫描的话就是执行器逐个判断读到的记录符不符合条件；1>索引查询的话直接指向-1就退出循环了2>全表扫描的话，要先指向全接口挨着把所有记录都读完才能退出循环。】



### 二、MySQL一行记录是怎么存储的？

1 MySQL的数据存在哪个文件里？

答：MySQL数据主要存储在磁盘上的文件中，具体文件位置和格式取决于存储引擎以及配置。

一般存储在默认的数据目录中，具体的文件夹路径为“/var/lib/mysql/数据库名”，该路径下一般有db.opt，表名.frm和表名.ibd三个文件。

**db.opt**-存储当前数据库默认的字符集和字符校验规则

**表名.frm**-保存每个表的元数据信息，主要包含表结构的定义

**表名.ibd**-保存每个表的数据信息，包括数据和索引等，也称为独占表空间文件。

【表空间文件的结构是什么样的？】

答：表空间由**段(segment)、区(extent)、页(page)、行(row)**组成。

**行**-数据库表的记录按行进行存放

**页**-InnoDB的数据以页为单位读写，默认大小16KB，同时也是**存储引擎磁盘管理的最小单元**。常见类型：数据页、undo日志页、溢出页。

【补充知识-B+树是什么？它的基本结构是什么样的？】B+ 树是一种**多路搜索树**，非常适合磁盘存储结构。特点是所有值都存放在叶子节点，非叶子节点(根节点)仅存放键值这样的索引信息。类似目录树，非叶子节点即为目录，叶子节点就是实际数据。叶子节点之间通过指针相连形成链表，方便范围查询。

**区**-表中数据量较大时，为某索引分配空间时就以区为单位，默认大小1MB。这样连续的64个页都会划分到一个区，**令链表中相邻页的物理位置也相邻**，便于使用顺序I/O，避免大量随机I/O产生的读取速度慢的问题。

**段**-表空间由各个段组成，一般分为**数据段**[存放叶子节点的区集合]、**索引段**[存放非叶子节点的区集合]和**回滚段**[存放回滚数据{旧版本数据，即事务对数据做修改之前的内容，类似数据修改历史的备份，便于撤销修改或提供历史版本的数据}的区集合]等。

2 InnoDB的行格式有哪些？

答：**共4种行格式，分别是Redundant、Compact、Dynamic和 Compressed 行格式**。

Redundant-已弃用

Compact-5.1版本行格式的默认设置，设计初衷是令一个数据页可以存放更多行记录。

Dynamic 和 Compressed-与Compact类似，5.7版本后默认Dynamic格式。

3 Compact行格式简介

一条完整记录分为**记录的额外信息**和**记录的真实数据**两部分。

**①记录的额外信息**

**1>变长字段长度列表**-用于管理记录中的变长字段，记录每个变长字段实际使用了多少字节的一个列表，仅用于数据表有变长字段时。排列时**按照列的顺序逆序存放**。若某变长字段值为NULL，其长度信息将不被记录，因为NULL不会存放在行格式中记录的真实数据里，但存放位置仍保留。

【为什么变长字段长度列表的信息逆序存放？】

答：为了**高效定位字段偏移量**，配合Compact行格式中记录字段数据的位置指针优化解析效率，**提升CPU缓存的命中率**实现高效读取。比如最后一个字段的长度在最前面，第一个字段长度的位置在长度列表的最后，这样第一个字段的数据和它的长度信息位置上在物理内存中离得更近。CPU每次加载数据的时候是以缓存行为单位的，数据本体和长度信息在同一个缓存行的时候，可以避免额外的内存读取从而提高缓存的命中率。总的来说，就是**优化了靠前字段的访问效率**。

**2>NULL值列表**-用于标记每个字段是否为NULL值的按位存储的数组，能够帮助数据库引擎迅速判断某字段是否存在数据，读取时跳过或不解码NULL字段。每个字段用1位(1/0)表示是否为NULL，8位一组同样是逆序存放，不足八个字段的在高位用0补齐凑够1字节。

【NULL值列表按位存储的优势】比用按字节存储节省空间；可以通过按位与迅速判断字段是否为NULL，从而引导数据库引擎迅速跳过无效字段。

**3>记录头信息**-用于管理记录之间的连接关系，主要是为了维护记录的状态信息(删除、最小记录等)，以及辅助数据库实现高效的遍历、插入、删除以及更新等操作。几个重要字段：**delete_mask**-标识此条数据是否被删除。**next_record**-下一条记录的位置，实现链表结构。**record_type**-表示当前记录的类型，0表示普通记录[存储的是表中的用户数据行]，1表示B+树非叶子节点记录[不存储真实的用户数据，而是用于导航的指针，帮助定位子节点页]，2表示最小记录[页开头，用于链表遍历]，3表示最大记录[页结尾，用于处理边界情况]。最大和最小记录都属于系统伪记录

**②记录的真实数据**

**1>row_id**-既没有指定主键，也没有唯一约束情况下使用的隐藏字段。这个时候row_id就可以当主键，唯一标识每行数据。

**2>trx_id**-用于记录最后修改该行数据事务ID的必需字段，表示这个数据由哪个事务生成。可以用于判断一个事务能否看到该行数据，即控制可见性。

**3>roll_pointer**-指向Undo日志中该行修改前的旧版本，支持回滚的必需字段。

上述三个字段共同构成InnoDB MVCC机制的基础，用于实现高并发下的数据一致性和事务隔离。

4 varchar(n) 中 n 最大取值为多少？

MySQL 规定除了 TEXT、BLOBs 这种大对象类型之外，其他所有的列(不包括隐藏列和记录头信息，但是包含变长字段长度列表和NULL值列表)占用的字节长度加起来不能超过 65535 个字节。即一行记录除了 TEXT、BLOBs 类型的列，限制最大为 65535 字节，注意是一行的总长度，不是一列。

**①单字段**-取决于用什么样的字符集，如果是单字节的话，就直接用65535-变长字段长度-NULL值列表长度；如果是多字节的话，比如UTF-8，每个字符占据3个字节，就要用65535/3-变长字段长度-NULL值列表长度。【其中，如果变长字段允许存储的最大字节数小于255字节，则变长字段长度为1字节；反之大于255字节时，就用2字节表示；NULL值列表长度都是1字节】

**②多字段**-要确保所有字段长度+变长字段字节数列表占用的字节数+NULL值列表占用的字节数<=65535

5 行溢出的话MySQL怎么处理呢？

答：InnoDB 存储引擎的Compact行格式通过使用**溢出页**来避免行溢出，允许表行大小超过 65,535 字节，但某些字段可能会被移动到外部页面存储到溢出页中，同时在原始数据页的真实数据处用20字节指向溢出页的地址。Compressed 和 Dynamic 这两个行格式，则直接在数据页中存储溢出页的地址，把所有的数据都放到溢出页中。

6 MySQL如何存放NULL值？

答：Compact行格式不直接在真实数据中存储，而是通过NULL值列表标记数值为NULL的列。NULL值列表占据1字节，如果全部数据没有NULL值，则可以直接省略这个列表。

## 索引篇

### 一、索引常见面试题

#### 1 什么是索引？

答：帮助存储引擎快速获取数据的一种数据结构，即索引是数据的目录。

存储引擎就是如何存储数据、如何为存储的数据建立索引、如何更新、查询数据等技术的实现方法。

#### 2 索引的分类

**①按数据结构**-B+树索引、Hash索引、Full-text索引

1>InnoDB根据不同的场景选择不同的列作为索引

**有主键**：默认使用主键作为聚簇索引的索引键

**没有主键**：选择第一个不包含NULL值的唯一列作为聚簇索引的索引键

**既没有主键也没有不包含NULL值的唯一列**：自动生成隐式自增id作为聚簇索引的索引键

2>什么是B+树呢？

**B+树是一种多叉树**，叶子节点存放数据，每个节点里的数据按主键顺序存放，非叶子节点存放索引。每一层父节点索引值都会出现在下层子节点索引值中，最终叶子节点中包括了所有索引值信息。每个叶子节点有两个指针，分别指向下一个叶子节点和上一个叶子节点，形成双向链表。

3>如何使用主键查询数据？

**查询索引**-从主键索引的根节点查找，遍历非叶子节点；**定位叶子节点**-在非叶子节点的遍历过程中，不断选择合适分支，逐步向下遍历，直到到达叶子节点；**返回数据**-B+ 树索引提供最终数据在数据页中的位置，由MySQL根据这个位置去数据文件中读取实际的数据行。

读取一次节点就是一次磁盘I/O操作。B+树相比B树和二叉树优势在于查询效率很高。

4>二级索引查询数据

**主键索引**-B+树叶子节点存放完整的数据记录

**二级索引**-B+树叶子节点存放主键的值

定位到叶子节点后获得的是主键值，再通过主键索引的B+树查询到对应的叶子节点，从而获得整行数据。该过程称为“**回表**”，总共经历两个B+树查询到数据。但是假如二级索引叶子节点保存的值就是要查询的数据，就不用再回表了，该过程称为“**覆盖索引**”。

**5>为什么选择B+树作为索引的数据结构？**

**B+树 vs B树**：B+树只在叶子节点存储数据，因此单个节点数据量更小，相同I/O次数下可查询更多节点；B+树叶子节点是双向链表连接，适用于基于范围的顺序查找。

**B+树 vs 二叉树**：B+树的父节点允许最大子节点数为d个，从而搜索复杂度为O(log_d N)，即使千万级别的数据也可以在3-4次I/O操作内完成查询；而二叉树每个父节点的子节点数只能是2个，即搜索复杂度为O(log_2 N)。

**B+树 vs Hash索引**：Hash索引进行等值查询时，搜索复杂度是O(1)；但它不适合做范围查询，应用范围较小。

**②按物理存储**-聚簇索引(主键索引)、二级索引(辅助索引)

具体内容详见“2→①→4>二级索引查询数据”的回表和覆盖索引

**③按字段特性**-主键索引、唯一索引、普通索引、前缀索引

**主键索引**-一张表最多只有一个主键索引，一般随表一起创建，索引列不允许有空值。

**唯一索引**-建立在UNIQUE字段上的索引，一张表可以有多个唯一索引，索引列的值必须唯一但可以有空值。

**普通索引**-既不要求字段是主键，也不要求字段是UNIQUE

**前缀索引**-对字符类型字段的前几个字符建立索引，减少索引占用的存储空间，提升查询效率。

**④按字段个数**-单列索引、联合索引

1>**联合索引**-建立在多列上的索引，即通过将多个字段组合成一个索引。此时的非叶子节点将存储一个联合索引内所有的字段，但仍然不存储真实数据，只存储字段名。使用联合索引查询数据时，将先查询A字段，A字段相同的情况下再查询B字段，这称为“**最左匹配原则**”。如果查询时不满足该原则，即不查询A直接从B开始查询，联合索引将失效，因为**B是全局无序局部相对有序的**。因此，**利用索引的前提是索引里的key是有序的**。

2>**联合索引的范围查询**-MySQL的联合索引遵循最左匹配原则，也就是**从索引的最左侧开始匹配，一旦遇到范围查询，后面的字段就不能再用于联合索引优化即停止匹配**。比如，对于全部都是等值匹配的索引就是精准匹配，所有字段都能用上可以完全命中索引；如果一旦某条字段的匹配用了类似“>，<”这种范围查询[不包括>=，BETWEEN，like%xx这种]，这条匹配后面的字段就都无法继续使用索引来加速查询了。因为范围查询后获得的数据，后面的字段是无序的，没办法再迅速匹配。不过如果范围查询位于索引的最后，还是可以使用索引的。

我们可以通过key_len知道优化器具体使用了多少字段匹配形成扫描区间的边界条件。另外key_len统一使用2字节表示可变字段的长度。

3>**索引下推**-一种查询优化策略，可以显著减少回表次数，提升查询效率。具体而言就是，**在使用索引扫描时，把<u>部分WHERE条件</u>提前应用到索引本身上筛选，而不是等回表后再用主表进行判断**。即在联合索引遍历B+树的索引页时，就对联合索引中包含的字段先做判断，直接把不满足条件的记录在索引页就过滤掉，而不是回表之后在主表中判断是否满足后续的条件。查询语句的执行计划时，如果Extra列出现Using index condition就说明使用了索引下推优化。技术上能实现是因为有些索引页中存的字段值是可见的，但是对于具体的类似SELECT*这样需要查询的字段内容就需要到主表里去读。注意，它主要是能加快复杂WHERE的执行速度。

4>**索引区分度**-建立联合索引时，一般要把区分度大的字段排在前面，让它可能被更多的SQL使用到。**区分度就是某个字段列不同值的个数除以表的总行数**。

5>**联合索引进行排序**-可以利用联合索引的有序性建立联合索引直接获得排好序的数据，避免文件排序提高查询效率。

#### 3 索引的适用场景

①索引有什么局限性？

答：占用物理空间；创建和维护耗费时间；降低表增删改的效率，增删改索引设计B+树对索引有序性的动态维护。

②索引的适用场景

答：字段唯一性限制；经常使用到WHERE查询条件的字段；经常需要GROUP BY和ORDER BY的字段，可以避免排序。

③什么时候不需要索引？

答：字段存在大量重复数据，索引起不到高效查询的作用；WHERE、GROUP BY和ORDER BY用不到的字段；表内数据太少；字段频繁更新。

#### 4 索引的优化方法

**①前缀索引优化**-使用某个字段中字符串的前几个字符建立索引

目的：减小索引字段的大小，从而增加索引页中存储的索引值，有效提升索引的查询速度。

局限性：order by不能使用前缀索引；前缀索引不能用于覆盖索引。

**②覆盖索引优化**

目的：避免回表，直接建立联合索引，就可以在索引B+树的叶子节点上找到，减少大量I/O操作。

**③主键索引最好自增**

优势：插入的新数据可以按顺序添加到当前索引节点的位置，不需要移动已有数据。**这种追加操作插入数据的效率很高**。

如果使用非自增主键，插入新数据时，需要页分裂操作，可能造成大量内存碎片，导致索引结构不紧凑，影响查询效率。

**④索引最好设置为NOT NULL**

目的：若索引列存在NULL会导致优化器进行索引选择时很复杂难以优化；NULL值虽无意义，但是同样占用物理空间，带来存储空间问题。

**⑤防止索引失效**【详见五、索引失效有哪些情况】

索引失效的常见情况：1>**使用左或左右模糊匹配时**会造成索引失效，如“like %xx"和"like %xx%"【但是like abc%是可以的，因为可以快速定位到abc开头的位置，但左和左右模糊匹配就不能用顺序查询了】；2>**查询条件中对索引列做计算、函数、类型转换操作时**，会造成索引失效【因为进行了操作后，就需要先对每一行的索引值先计算结果再比较条件是否成立，这样B+树的有序查找同样没法儿用。如果要避免的话，可以直接对常量做函数，而不是对列索引，比如选择日期具体大于某一天，而不是构造日期函数对时间列的索引进行操作】；3>**联合索引必须按照最左匹配原则，否则会失效**；4>**WHERE子句中，若在OR前的条件列是索引列，在OR后的条件列不是索引列**，也会失效【MYSQL处理OR条件时，要么分别用两个条件查索引再做并集，索引合并；要么就直接全表扫描，一次性判断两个条件。】【如果OR两边的条件不能同时用到索引，MYSQL为了避免执行两套索引扫描，以及合并的复杂成本，就会直接放弃索引，转而执行全表扫描】。

常见的扫描类型[执行效率从低到高]：All全表扫描；index全索引扫描；【前述两种方式开销都比较大，要尽量避免】range索引范围扫描；ref非唯一索引扫描；eq_ref唯一索引扫描[通常用于多表联查，通过相同的关联条件进行查表]；const结果只有一条的主键或唯一索引扫描[通常与常量比较，查询效率更快]

extra重要指标：1>Using filesort：查询语句包含group by操作，且无法利用索引完成排序操作，必须通过相应的排序算法进行，效率极低；2>Using temporary：使用临时表保存中间结果，常见于排序order by和分组group by，效率低；3>Using index：所需数据只需在索引即可获得，不需再回表，效率不错。

### 二、从数据页的角度看B+树

#### 1 InnoDB是如何存储数据的？

答：记录按照行来存储，但InnoDB数据库的读取是按照“数据页”为单位进行读写的，即读取一条记录时以页为单位将其整体读入内存。数据库的I/O操作最小单位是页，默认大小16KB。

**①数据页具体内容和作用**

文件头-表示页信息，有两个指针分别指向上一个和下一个数据页，形成一个双向链表，使得数据页之间逻辑上连续

页头-表示页的状态信息

最小和最大记录-两个虚拟的伪记录，分别表示页中的最小和最大记录

用户记录-存储行记录内容

空闲空间-页中没被使用的空间

页目录-存储记录的相对位置，对记录起索引作用

文件尾-校验页是否完整

**②数据页如何组织数据？**

数据页中的记录按照“主键”顺序组成单向链表，便于插入和删除，但检索效率不高。

**③页目录如何创建？**

所有记录划分为n个组，包括最小和最大记录，但不包括标记为删除的记录；

每个记录组的最后一条记录即为组内最大的记录，然后在每组最后一条记录的头信息中存储该组的记录条数，作为n_owned字段；

页目录存储的是每组最后一条记录的地址偏移量，称之为槽(slot)，每个槽指向不同组的最后一条记录。

因此，页目录由多个槽组成，槽相当于分组记录的索引。又因为记录时按照主键顺序排列，因此通过槽查找记录时可以使用二分法迅速定位到查询记录应该在哪个槽，再遍历槽内所有记录即可，就不需要从最小记录开始遍历整个页中的记录链表。

另外，第一组中只能有1条记录，最后一组只能有1-8条记录，中间组的记录条数应在4-8条之间。

#### 2 B+树如何进行查询的？

**①为什么出现B+树索引？**

当需要存储大量记录时，需要大量数据页，需要通过建立合适的索引，迅速定位记录所在的数据页。因此InnoDB采用B+树作为索引。

B+树结构上矮胖，所需的磁盘I/O次数更少，因而更适合进行关键字范围的查询。

**②B+树的特点**

B+树的每个节点都是一个数据页；

但只有叶子节点(最底层节点)才存放数据，非叶子节点仅存放目录项作为索引；

非叶子节点分为不同层次，通过分层降低每一层的搜索量；【比如1层能区分100个key，2层就能区分100×100=10000个key】【总体来说，节点存储的关键字越多，层数越少，从而搜索路径就越短】【可以把原本O(n)的查找变成O(log_{m}n)】

所有节点按照索引键大小排序构成双向链表，便于范围查询。

**③B+树如何查询？**

通过二分法迅速定位包含该记录的页，再在该页内进行二分法迅速定位记录所在的槽，最后在槽内遍历查找。

#### 2 聚簇索引和二级索引(非聚簇索引)？

**①区别**

聚簇索引的叶子节点直接存放实际数据，即所有的完整用户记录；【显然聚簇索引只能有一个】

二级索引的叶子节点存放主键值。【为了实现非主键字段的快速搜索，可以有多个二级索引】

**②聚簇索引的创建**

默认主键作为聚簇索引的索引键；

没有主键时，选择<u>第一个</u><u>不包含NULL值</u>的<u>唯一列</u>为索引键；

上述均不满足时，自动生成一个隐式自增id列作为索引键。

**③回表和索引覆盖**

二级索引查询的数据不是主键时，需要在查到主键后再去聚簇索引中获得相应的数据行，即回表；

若二级索引查询的数据刚好是主键，就不再需要查询聚簇索引，即索引覆盖。

### 三、为什么MySQL采用B+树作为索引？

#### 1 怎样索引的数据结构是好的？

①为什么希望查询过程中少磁盘I/O次数？

答：因为索引和记录都保存在磁盘上，而磁盘相比内存读取速度很慢。磁盘读写的最小单位扇区只有512B，操作系统最小读写单位是块为4KB，即一次I/O操作会读写8个扇区。

而通过索引查找数据时，首先要从磁盘读取索引到内存，再通过索引到磁盘中找到对应的数据，再读入内存。总之查询过程会发生多次磁盘I/O，随着次数增多，消耗时间也越大。因此，要尽可能使查询过程减少磁盘的I/O次数。

**②适合MySQL索引的数据结构需要满足什么条件？**

答：一方面要尽可能减少磁盘的I/O操作，另一方面不仅要高效查询某个记录，还要高效地执行范围查找。同时还要考虑数据结构增删改的时间复杂度。

#### 2 什么是二分查找？

每次查询时计算中间位置，并与要查询的数值进行比较区分下一步查询去左边还是右边。但前提是索引的数据是按顺序排列的。它的时间复杂度是O(logn)。

#### 3 什么是二分查找树？

①为什么要设计二分查找树？

线性排序的数据插入新元素时性能太低，需要把后面的所有元素都进行移动。另外，有序数组使用二分查找时，还要不断计算中间位置。所以需要设计一个非线性而且天然适合二分查找的数据结构。

**②二叉查找树**

构成-找到二分查找中用到的所有中间节点，把它们用指针连起来，然后再把最中间的节点作为根节点。查询时只需将查找数据不断与节点数据比较即可。

特点-一个节点的左子树的所有节点必小于这个节点，右子树的所有节点都大于这个节点。树的高度即为每次查询数据时磁盘I/O操作的次数。

插入新节点-二叉树是一个跳跃结构，不必连续排列。插入新节点时，就不断用新节点和已有节点比较大小，然后通过比较结果判断是去左树还是右树，直到发现某个节点的左树或者右树是空的，就把新节点挂到这个空位上即可。如果出现相等了，就忽略或者处理重复，一般不允许重复插入。

局限性-极端情况下，如果每次插入的数据都是最大或者最小元素，二叉查找树就会退化成一条链表，时间复杂度再次退化成O(n)。

**③为什么二叉查找树不适合进行范围查询？**

理论上可以通过中序遍历和判断进行范围查询，但是效率会非常差。因为**节点分散**：它的节点是离散存储的，每个节点都有左右指针，进行范围查询的话需要在树里跳来跳去，访问内存的局部性差；**无叶子链表**：缺乏像B+ 树那样的串联链表，不能直接顺序遍历叶子链表，只能依赖递归遍历，从根开始递归左右子树；**可能退化**：而且可能存在退化问题，如果不平衡的话就退化成链表，再进行范围查询时几乎等于线性扫描。

#### 4 什么是自平衡二叉树？

动机-为了解决二叉查找树在极端情况下退化成链表的问题，提出平衡二叉查找树(AVL树)。

设计-在二叉查找树的基础上增加条件约束：每个节点左右子树的高度差不能超过1，确保时间复杂度始终维持在O(logn)。

插入新节点[以AVL为例]-首先按普通二叉查找树插入新节点；然后从下往上回溯，检查平衡因子[平衡因子=左树高度-右树高度]是否失衡，如果失衡要通过**旋转操作**修复。

旋转操作-1>左左型，即新节点插入某节点左子树的左子树，则进行右旋；2>右右型，即新节点插入某节点右子树的右子树，则进行左旋；3>左右型，即新节点插入某节点左子树的右子树，则先进行左旋子树再进行右旋根；4>右左型，即新节点插入某节点右子树的左子树，则先进行右旋子树再进行左旋根。

局限性-随着插入元素的增多，树高也变高，影响整体数据查询效率。

解决方法-修改成M叉树。因为树的分叉数M越大，树的节点增多时，M叉树的高度也会远小于二叉树的高度。

#### 5 什么是B树？

动机-即使是自平衡二叉树，每个节点也只能有2个子节点，节点数过多的时候还是影响查询效率

解决方案-允许每个节点有M个子节点，进而降低树高。M称为B树的阶，B树是一个多叉树。

局限性-B树的每个节点都包含数据(索引+记录)，记录的大小可能远远超过索引，读取过程中无用的记录数据不仅增加了磁盘I/O操作次数，而且占用内存资源，可能限制查询速度；B树也不适合做范围查询，因为需要使用中序遍历，会涉及多个节点的磁盘I/O问题，导致整体速度下降。

#### 6 什么是B+树？

①与B树的差异

·叶子节点才存放实际数据(索引+记录)，非叶子节点仅存放索引

·所有索引都会在叶子节点出现，叶子节点间构成有序链表

·非叶子节点中有几个子节点就有几个索引

·非叶子节点的索引也会出现在子节点中，而且是子节点所有索引中的最值

②单点查询

数据量相同条件下，B+树非叶子节点可以存放更多索引，从而树高更矮，查询到底层的磁盘I/O次数也会更少。总体来说，B树查询的时间复杂度波动比较大。

③插入和删除效率

由于B+树的非叶子节点仅存储索引，所以它存储的其实是子节点的最大或最小关键字的副本。这事实上是冗余的，因为真实数据仅仅存储在叶子节点这里，非叶子节点这里只相当于导航索引，表示这个子树最大或者最小到多少。所以在插入或删除的时候，只需要在父节点里更新几个关键字即可，不需要进行繁琐的旋转来保持平衡。具体而言，**插入时最多就是节点分裂+父节点索引更新，删除时最多就是节点合并或借位+父节点索引更新**。因此，B+树的插入和删除效率更高。

④范围查询

B+树所有叶子节点之间有链表进行连接，非常利于范围查找。

⑤MySQL中的B+树

特点：B+树叶子节点之间通过双向链表连接，可以进行双向遍历；B+树节点内容是数据页，数据页内存放用户的记录和各种信息。

### 四、MySQL单表不能超过2000W行吗？

1 单表数量限制

主键的大小可以限制表的上限

2 表空间

真实的表数据事实上是存放在ibd文件中，即表空间中，并被分为多个小数据页进行存放。

3 页的数据结构

新申请的数据页中并没有用户记录这个部分。数据页中每插入一条记录，就从尚未使用的**空闲空间**中申请一个记录大小的空间划分到**用户记录**里。空闲空间都被用户记录替代掉，就说明这个数据页使用完了。

4 索引的数据结构

索引页指存放索引项的数据页，它记录的是数据页和索引页的最小主键id和对应的页号。

如果数据量比较大，索引分散在多个页，需要通过**层级结构**迅速定位索引页，避免全量扫描所有页。即最上层的根页存放大目录，记录范围边界；中间层的非叶子索引页进一步划分范围；最底层的叶子页存放真正的数据行指针。即上层页存放范围索引(关键字+指针)，下层页存放更细的范围或真实数据，页与页之间通过指针连接形成“父子关系”。

5 单表建议值

在B+树中，非叶子节点里的每条数据都指向新的页，若指向叶子节点即为一行行的数据，若继续指向非叶子节点即会指向新的页。那么假设非叶子节点指向其他页的数量为x，叶子节点能容纳数据的行数是y，B+树的层数是z。则，B+树可容纳数据的总数为[x^(z-1)]*y。

x=15KB×1024/12=1280行。15KB表示一个数据页上用于真实存储的空间，12B表示一个主键(8B)+一个页号(4B)的大小。

y=15×1024/1000=15行。叶子节点要存放真正的行数据，需要包括字段类型、数量等各种内容，此处按1KB计算。

当z=3时，表示B+树有三层，这时的数据量大概就是2.45kw。一般的B+树最多也就是3层。

【注：由于叶子节点存放真正行数据的大小是不固定的，因此在相同层级的条件下，单表最大建议值也不尽相同。】

### 五、索引失效有哪些情况？

#### 1 索引的存储结构？与MySQL使用哪种存储引擎有关。

InnoDB存储引擎中B+树索引的叶子节点保存数据本身

MyISAM存储引擎中B+树索引的叶子节点保存的是数据的物理地址

#### 2 对索引使用左模糊或者左右模糊匹配

即类似like %xx或like %xx%。

因为B+树的索引是按照索引值的有序排列存储的，只能根据前缀进行比较。

#### 3 对索引使用函数

即在查询条件中对索引的字段使用函数。

因为索引保存的是索引字段的原始值，而不是经过函数计算后的值。如果使用函数的话，就要走全表，全部计算一遍后再逐个比对。

但是8.0以后可以通过函数索引功能，针对函数计算后的数值再建立一个索引进而查询。

#### 4 对索引进行表达式计算

原因同上。

#### 5 对索引隐式类型转换

比如索引字段是字符串类型，但条件查询输入的参数类型是整型。相当于MySQL要通过一个函数把全表的字符串都转换成数字，然后和输入的整型数进行比较。

但如果索引字段是整型，而查询是字符串类型，则不会失效。**因为MySQL遇到字符串和数字比较时，会自动将字符串转换为数字**。这里只是对输入的参数进行了函数转换，而没有对索引字段做任何函数，所以不会失效。

#### 6 联合索引非最左匹配

多个普通字段组合在一起创建的索引称为联合索引，必须按照最左优先的方式进行索引匹配。【这里涉及到索引下推的功能，详见一2索引的分类④3>】

因为联合索引时，数据是按照索引的第一列排序的。如果从第二列开始，就不能走这个联合索引了。

#### 7 WHERE子句中的OR

即在OR前的条件列是索引列，而OR后的条件列不是索引列。

因为OR的含义是两个满足其一即可，因此只要有一个条件不是索引列，就会进行全表扫描。解决方案就是把非索引列也设置成索引列就行了。

### 六、count(*)和count(1)的区别？哪个性能最好？

#### 1 哪种count性能最好？

答：count(*)=count(1)>count(主键字段)>count(字段)

①什么是count()？

答：count()是一个聚合函数，参数可以是字段名或任意表达式。用于统计符合查询条件的记录中，函数**所指定的参数不为NULL**的记录有多少。

count(1)事实上是在统计表中有多少条记录，因为1这个表达式是一个纯数字，永远不为NULL。

②count(主键字段)如何执行？

MySQL的Server层会通过一个循环向InnoDB读取记录，只要指定参数不为NULL，count变量就累计+1，直到符合查询的记录全部读完，退出循环。最终将count变量的数值发送给客户端。

InnoDB循环遍历聚簇索引，把读到的记录返回给Server层，并读取记录中的主键。如果可以通过二级索引实现，则优先选择二级索引。

③count(1)如何执行？

InnoDB循环遍历聚簇索引，还是把读取记录返回给Server层，**但不读取记录中的任何字段值**。而是每读取一条记录，就将count变量累计+1。同样，如果表中有二级索引，优先遍历二级索引，而且是key_len最小的二级索引。

【可以看到，count(1)比count(主键字段)少一个步骤，因此count(1)的执行效率更高一些。】

④count(*)如何执行？

count(*)事实上等价于count(0)，执行过程与count(1)基本无异。

⑤count(字段)如何执行？

该函数执行效率最差，因为它不是索引，而是普通字段，一般需要通过全表扫描进行计数。

【总结：执行count(1/*/主键字段)时，若表里存在二级索引，优化器会优先选择key_len最小的二级索引进行扫描。】

#### 2 为什么通过遍历的方式进行计数？

① MyISAM存储引擎

每张MyISAM的数据表都有一个meta信息自动存储了row_count的数值，即表的行数信息，因此执行count函数时只要直接读取row_count值即可。

② InnoDB存储引擎

InnoDB不会在表的元数据中维护一个全局的精确行数，因此执行count函数时必须遍历聚簇索引。

这主要是因为它支持**事务和MVCC(多版本并发控制)**。同一时刻，不同事务能看到的行数可能是不一样的[比如，事务A删除了100行，但是事务B还没提交，事务C查询时可能看不到这100行]，因此对于返回多少行也是不确定的。而如果InnoDB也维护一个全局计数器的话，就无法保证不同事务隔离级别下的正确性。

总体分析，InnoDB必须保证计数结果和当前事务视图一致。由于存在MVCC，因此当前事务的可见行依赖于undo log和版本信息，只能逐行判断可见性再累计计数。

答：InnoDB要通过遍历计数，是因为它必须保证在支持事务和MVCC的前提下，每个事务看到的行数都是正确的，确保不同事务隔离级别下的正确性。

#### 3 如何优化count(*)？

**① 近似值**

面对大表的记录统计，如果对统计个数不需要很精确，可以通过show table status或explain命令对表进行估算，而不是真正地去查询。

**② 额外表保存计数值**

如果需要精确获得表记录的总数，可以将计数值保存到单独的一张计数表中。然后在增删操作时，额外维护该计数表。

### 七、MySQL分页有什么性能问题？该如何优化呢？

#### 1 哪？



