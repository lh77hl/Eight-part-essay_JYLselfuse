# 计算机网络

## 基础篇

### 一、TCP/IP网络模型有哪几层？

1 为什么要有TCP/IP模型？

答：同设备的不同进程通信有多种方式(管道、队列、共享内存、信号等)，不同设备的不同进程进行通信时需要网络通信，**为了兼容设备的多样性，协商采用通用的网络协议**。

2 TCP/IP模型有哪些层，每一层的功能是什么？

答：一共包括4层：**应用层、传输层、网络层和网络接口层**。

**①应用层**[操作系统中的用户态]：专注于**为用户提供一组应用程序**，如HTTP、DNS、FTP等。

**②传输层**：为应用层提供网络支持，仅仅是应用间数据传输的媒介，辅助**实现端到端的通信**。这里涉及两个协议-传输控制协议(Transmission Control Protocol, **TCP**)和用户数据报协议(User Datagram Protocol, UDP)。

TCP为了保证数据包可靠地传输给对方，包括流量控制、超时重传、拥塞控制等特性。而UDP仅仅只负责发送数据包，不保证抵达，优点就是实时性和高传输效率。

【传输数据很大时怎么办呢？】当传输层数据包大小超过MSS(TCP最大报文段长度)时，会将数据包分块[每个分块称为一个TCP段]传输，某部分丢失或损坏时仅重传这一部分即可。

【一台设备同时有很多应用在接受或传输数据怎么办呢？】采用编号[即端口]来区分应用，传输层报文中携带的端口号可以识别出给哪个应用。通常80用于Web服务器，22端口用于远程登录服务器。

**③网络层**：**负责网络包的封装、分片、路由、转发**，实现实际的传输功能。最常用协议-网络协议(Internet Protocol, **IP**)。

IP协议将传输层的报文作为数据，再加上IP包头组成IP报文，IP报文大小超过MTU[通常1500字节]时会再次分片。

IP协议具有**寻址能力，确定下一步目的地**。为了寻址方便，IP地址分为两种意义：**网络号**-标识子网和**主机号**-标识同一子网下的不同主机。

IP协议还具有**路由能力，根据下一步目的地确定具体路径**。实际场景的两台设备间通过网关、路由器、交换机等众多设备连接，具有多条网络路径。当数据包到达一个网络节点后，通过路由算法决定下一步路径，路由寻址即获取目标地址的子网并报数据包转发给对应网络。

【网络层传输数据时该怎么找到目标设备呢？】网络层采用IP地址进行编号区分设备。IPv4协议地址共32位分4段，每段8位[IPv6采用128位地址长度，提供了更大的地址空间，支持自动配置，报头文格式简化；支持端到端的安全性；采用冒号分隔的十六进制表示法]。

【给定一个IP地址，你怎么计算它的网络号和主机号？】假设IP地址是10.100.122.2，已知子网掩码255.255.255.0. IP地址和子网掩码按位与运算即为网络号；IP地址和取反的子网掩码按位与运算即为主机号。寻址时先匹配网络号再匹配主机号。

**④网络接口层**[网卡层次]：**负责网络包在物理网络中的传输**，比如网络包的封帧、 MAC 寻址、差错检测，以及通过网卡传输网络帧等。为网络层提供“链路级别”传输的服务，负责在以太网、WIFI这样的底层网络上发送原始数据包，使用MAC地址标识网络上的设备。

IP头中接收方的IP地址表示网络包的目的地。以太网则采用MAC地址进行通讯，由网络接口层加上MAC头，包含接收方和发送方的MAC地址等信息。

【什么是以太网？】一种在局域网内，把附近设备连接起来使之进行通讯的技术。电脑上的以太网接口，WIFI接口，以太网交换机，路由器的以太网口，网线等都是以太网的组成部分。

【大型数据怎么传输的呢？】首先应用程序数据包括HTTP头部和消息体，这一整个是将要传输的数据包。当其大小超过MSS时，先在传输层由TCP分成数据块并添加TCP头部。然后由网络层进行传输，每个数据块传输时都要添加IP头部，MTU长度包括IP头+TCP头+数据块。最后网络接口层在IP头前面加上MAC头，封装成数据帧[加上帧头和帧尾]发送到网络上。



### 二、键入网址到网页显示，期间都发生了什么？

1 HTTP

第一步：**解析URL**，确定web服务器和文件名，**生成发送给Web服务器的请求信息**。

【一条URL里都包含哪些元素或信息？】**访问数据的协议**http: + **服务器名称**//web服务器+**表示数据源的路径**，没有路径名时，访问根目录下的默认文件。

2 DNS

第二步：委托操作系统发送消息前，**查询服务器域名对应的IP地址**。

【什么是DNS？】DNS服务器专门保存了Web服务器域名和IP的对应关系。DNS的域名通过英文句点分割，越靠右表示层级越高。最后的句点表示根DNS服务器，下一层是顶级域，再下一层是权威DNS服务器(类似google.cn)。

【域名解析的具体工作流程是怎样的？】

答：①客户端发出的DNS请求[比如询问请求访问的IP地址是什么]首先发给本地DNS服务器[即客户端的TCP/IP中的DNS服务器地址]；②本地DNS服务器收到请求后，分两种情况，若缓存中可以找到则直接返回IP地址，若缓存中不存在则询问根域名服务器[根域名服务器不直接用于解析而是指明路径]；③根域名服务器将请求转给顶级域名服务器；④顶级域名服务器进一步将请求转给权威域名服务器；⑤权威域名服务器是域名解析结果的出处，查询后将IP地址告知本地DNS；⑥最终本地DNS将获得的IP地址返回客户端。[通常情况下，浏览器都会先访问自己的缓存，没有的话问操作系统，操作系统没有就去hosts文件，最后大家都没有才会去访问本地DNS。]

3 协议栈

第三步：通过DNS获得IP地址后，**HTTP的传输工作由操作系统中的协议栈完成**。具体而言，应用程序调用Socket库委托协议栈工作。协议栈上半部分的TCP和UDP协议负责接受应用层的委托进行收发数据。协议栈下半部分的IP协议控制网络包收发操作。IP协议中进一步包含ICMP[告知网络包传送过程中产生的错误和各种控制信息]和ARP[根据IP地址查询以太网的MAC地址]协议。

4 TCP

第四步：HTTP传输数据前，需要**TCP建立连接**，即TCP的三次握手。目的是确保双方都有发送和接收的能力。

【TCP协议中的报文头部格式是怎样的？】

答：①必定包括**源端口号和目标端口号**，确定发给哪个应用；②必须有包的**序号**，避免包乱序；③**确认号**，确认对方是否收到发送，避免丢包；④**状态位**，双方维护连接时会引起状态变更；⑤**窗口大小**，标识当前处理能力，做**流量控制**确保发送速度，做**拥塞控制**控制发送速度。

TCP连接状态的查看可以通过netstat -napt命令查看。

当HTTP请求消息较长超过MSS长度时，TCP会拆解成数据块发送，每个数据块前都加上TCP头信息交给IP模块进行发送。

TCP协议里有两个端口：浏览器监听端口[通常随机生成]和Web服务器监听端口[HTTP默认为80，HTTPS默认为443]。

双方建立连接后，TCP报文的数据部分存放HTTP头部和数据。

5 IP

第五步：**TCP模块委托IP模块将数据封装成网络包发送给通信对象**。

IP协议里需要有**源地址IP**[客户端输出的IP地址]和**目标地址IP**[通过DNS域名解析获得的Web服务器IP]。另外IP包头的**协议号**填写06十六进制表示采用TCP协议。

【客户端存在多个网卡时，IP头部的源地址IP该怎么选择呢？】这里的选择事实上是在判断多块网卡中应该采用哪个网卡进行发包。根据路由表规则来判断。步骤就是，将web服务器的目标IP分别与各个网卡条目的子网掩码进行与运算，然后选择匹配成功的IP地址作为源地址。如果全都匹配失败了，就自动匹配默认网关。

6 MAC

第六步：**网络包在IP头部前加上MAC头部**。

MAC头部包含了接收方和发送方的MAC地址信息，用于两点间的传输。一般TCP/IP通信里，MAC包头仅使用IP协议[0800]和ARP协议[0806]。

【如何确认MAC发送方和接收方？】发送方直接读取网卡ROM里的数值。接收方的MAC由ARP协议帮助寻找，在以太网中以广播的形式获取对应IP地址[这个IP地址通过解析DNS域名获得]的MAC地址。[同样，如果ARP缓存中有对方的MAC地址就直接使用，没有的话再广播查询]

7 网卡

第七步：**网卡将数字信息转换为电信号在网线上进行传输**。

网卡驱动程序获得网络包[存放在内存中的一串二进制数字信息]后，复制到网卡内的缓存区中，进一步在其开头加上报头和起始帧分界符[表示包的起始位置]，在末尾加上用于检测错误的帧校验序列[检查包传输过程是否有损坏]。

8 交换机

第八步：**交换机将网络包原样转发到目的地**。交换机接收到达网线接口的电信号后，将其转换为数字信号，校验包末尾的错误码后，没问题就放到缓存区。然后要查询一下MAC地址表确定MAC地址对应的端口号，把信号发送到这个端口。

【交换机和网卡的工作方式有哪些不同呢？】**最大的不同就是交换机端口不具有MAC地址**。网卡本身具有MAC地址，并需要核对收到包的接收方MAC地址，如果不是发给自己的要丢弃；而交换机接口没有核对这个流程，全盘接收所有的包并存放到缓存区。

【如果MAC地址表中找不到收到的MAC地址怎么办呢？】原因：①可能该设备还未向交换机发送过包；②可能该设备一段时间没工作被地址表删除了。方案：这个时候，交换机就给除了源端口外的所有端口都发一遍这个包，只有目标设备才会做出响应，只要返回了响应包，交换机就会把这个地址写入MAC地址表供下次使用。还有一种情况，如果接收方MAC地址是一个广播地址[MAC地址：FF:FF:FF:FF:FF:FF；IP地址：255.255.255.255]，也是把包发给除源端口外的所有端口。

9 路由器

第九步：**路由器将网络包转发给下一个路由器或目标设备**。同样是通过查表判断包的转发目的地。

【路由器和交换机的区别是什么？】路由器基于IP设计，俗称三层网络设备，各个端口都有MAC地址和IP地址；交换机基于以太网设计，俗称二层网络设备，其端口不具有MAC地址。

【路由器的原理是什么？他又是怎样工作的？】

答：①路由器端口接收发给自己的以太网包，经过路由表查询后由相应端口把以太网包再发出去。②在接收包时，路由器的交换机模块先将电信号转换为数字信号，然后校验包末尾的错误码，没问题后检查接收方MAC地址确认是丢弃还是放入缓存区。③完成包接收后，路由器丢弃MAC头部[MAC头部就是用于把包送达路由器]，然后根据IP头内容进行包转发操作。④转发的时候根据接收方IP地址查询路由表中的目标地址栏匹配路由作为转发目标。⑤发送时也是根据路由表的网关列判断对方地址，若网关为IP地址则继续由路由器转发，若网关为空则IP头中的接收方IP地址已到达无需继续转发。⑥通过ARP协议根据获得的IP地址查询接收方MAC地址继续发送，发送的网络通过交换机到达下一个路由器，层层转发直到最终目的地。

10 服务器与客户端

第十步：服务器层层检验数据包的MAC头部、IP头部、TCP头部，根据TCP头中的端口号将包发给HTTP进程，HTTP进程把请求页面封装在HTTP响应报文里。HTTP响应报文经过TCP、IP、MAC头部层层封装后，经过网卡，并经过交换机和路由器到达客户端。最终客户端解析HTTP响应报文后，由浏览器渲染页面获得最终数据。最后的最后，客户端向服务器发起TCP四次挥手断开双方连接。



### 三、Linux系统如何收发网络包？

1 Linux网络协议栈

①应用程序通过系统调用，与Socket层进行数据交互；②经过传输层(TCP封装)、网络层(IP封装)和网络接口层(MAC封装)；③最终通过网卡驱动程序和硬件网卡设备传输。

2 Linux接收包流程

网卡是计算机里的一个硬件，专门负责接收和发送网络包。

每当网卡收到一个网络包，就触发一个中断告知操作系统。

为了解决频繁中断带来的性能开销，Linux内核引入NAPI机制，混合“**中断和轮询**”的方法接收网络包。核心是**不采用中断的方式读取数据，而是采用中断唤醒数据接收的服务程序**，然后采用poll的方式轮询数据。

【DMA技术指什么？】对于到达的网络包，DMA技术先把网络包写入指定的内存地址，然后网卡向CPU发起硬件中断，CPU根据中断表调用已注册的中断处理函数。这里的中断函数包括硬件中断和软中断。**硬件中断处理函数**：①先“暂时屏蔽中断”，令CPU知晓内存中有数据，下次收到的数据包直接写内存，避免CPU不停被中断。②发起软中断恢复刚才被屏蔽的中断。**软中断处理函数**：①采用内核中的ksoftirqd线程专门处理，收到后轮询处理数据。②从Ring Buffer中获取一个数据帧，用sk-buff表示作为一个网络包交给网络协议栈逐层处理。③在网络协议栈这一步，在网络接口层检查报文的合法性，不合法的丢弃合法的确认上层协议类型[IPv4/IPv6]，去掉帧头帧尾交给网络层；网络层取出IP包判断走向[交给上层处理还是继续转发]，若发给本机则从IP头里确认上层协议类型[TCP/UDP]，去掉IP头交给传输层；传输层取出TCP或UDP头，根据四元组“源IP、源端口、目标IP、目标端口”作为标识，找出对应Socket把数据放到它的接收缓存区；最后应用层程序调用Socket接口，把数据拷贝到应用层缓存区唤醒用户进程。

3 Linux发送包流程

①应用程序调用Socket发送数据包接口，从用户态陷入内核态的Socket层。内核申请一个sk-buff内存，把用户待发送的数据拷贝到sk_buff内存并将其加入发送缓冲区。②网络协议栈从Socket发送缓存区中取出sk_buff，按照TCP/IP协议从上到下逐层处理。③采用TCP协议发送数据时，先拷贝一个sk_buff副本[为了确保丢失重传，收到对方的ACK之前，sk_buff都不会被删除]，然后对sk-buff填充TCP头。④网络层进一步选取路由、填充IP头、对过大数据包分片。⑤网络接口层通过ARP协议获得下一跳MAC地址，并对sk_buff填充帧头和帧尾，放到网卡的发送队列。⑥这些工作准备完后触发“软中断”告知网卡驱动程序有新的数据包要发送。⑦驱动程序读取sk_buff，并挂到RingBuffer中，映射到网卡可访问的内存DMA区域，触发真实发送。⑧发送完成后，网卡触发硬中断释放sk_buff内存和清理RingBuffer内存，直到收到TCP报文的ACK应答时传输层才会释放原始sk_buff。

【sk_buff可以表示各个层的数据包，应用层的data，TCP层的Segment，IP层的packet，数据链路层的frame，为什么全部的数据包只用一个结构体描述呢？】

答：协议栈采用分层结构，上下层传递数据时需要增加或去掉包头，若每一层都用一个结构体，层间传递会发生多次拷贝大大降低CPU效率。因此主要是为了层级间传递数据时不发生拷贝。其实现是通过调整sk_buff中data的指针，即接收报文时，从网卡驱动开始，通过增加skb->data的值逐步剥离协议头部；发送报文时，创建sk_buff结构体，在数据缓存区头部预留足够空间填充各层头部，通过减少skb->data的值逐步增加协议头部。

【发送网络数据时，共涉及几次内存拷贝操作？】

答：共三次。①发送数据前，从用户态陷入内核态，内核会申请一个sk_buff内存，把待发送数据拷贝入sk_buff内存并加入发送缓冲区。②使用TCP协议时，从传输层进入网络层的时候，每个sk_buff被克隆一个新副本。副本被送往网络层，发送完就释放。原始的sk_buff保留在传输层，直到TCP收到ACK再释放[防止丢包的时候原始数据丢失无法重传，确保TCP的可靠传输]。③若IP层发现sk_buff大于MTU时，会再申请额外的sk_buff，把原来的sk_buff拷贝为多个小的sk_buff。



## HTTP篇

### 一、HTTP常见面试题

#### 1 HTTP基本概念

①HTTP是什么？

答：HTTP即超文本传输协议(**H**yper**T**ext **T**ransfer **P**rotocol)。它是一个用在计算机世界里的**协议**，使用计算机能够理解的语言建立了一种计算机间交流通信的规范，以及相关的各种控制和错误处理方式。它是一个计算机世界里专门用来在两点间**传输**数据的约定和规范，作为双向协议，整个传输过程的中间方都需要遵从该协议。它传输的内容是**超文本**，即超越普通文本的文本，是文字、图片、视频等的混合体，可以通过超链接从一个超文本跳转到另一个超文本。总的来说，**HTTP就是一个在计算机世界里专门在*两点间传输*文字、图片、音频、视频等*超文本数据*的*约定和规范*。**

②HTTP常见的状态码

答：共有五类。

一类属于**提示信息**，主要是协议处理的中间态。

二类表示服务器**成功**处理客户端请求。**200 OK**表示一切正常，对于非Head请求*[Head属于一种HTTP方法，即请求方式，它只返回响应的头，不返回正文内容。非Head指的就是除了Head以外的请求，比如Get、Post、Put等，这些请求会返回完整响应，包括头和内容(body)]*，服务器返回的响应头*[响应头是服务器对浏览器返回的一组信息，用于描述响应的元数据，包括数据类型，长度，服务器信息，响应时间等]*有body数据*[即响应体，服务器真正返回的数据本身]*，即服务器通常会在返回时附带响应体数据；**204 No Content**与200 OK的区别就是响应头没有body数据；**206 Partial Content**表示响应返回的body数据只是其中一部分，应用于HTTP分块下载或断点续传。

三类表示客户端请求的资源发生了变动，需要用新的URL重新发送请求获取资源，即**重定向**。**301 Moved Permanently**表示永久重定向，即请求资源不在，需改用新的URL再次访问；**302 Found**表示临时重定向，即请求资源还在，但需要暂时用另一个URL访问[二者一般会在响应头里使用Location字段指明后续跳转的URL，浏览器自动重定向新URL]。**304 Not Modified**不具有跳转意义，其请求的资源未修改，重定向已存在缓冲文件，客户端可以继续使用缓存资源[该状态请求成功但不会有响应体，因为这个资源上次请求后没有修改过，所以可以直接使用本地缓存的版本，不需重新下载，节省带宽和加载时间]。

四类表示**客户端发送的报文有误**，服务器无法处理，为错误码。**400 Bad Request**表示客户端的报文有误，笼统错误码。**403 Forbidden**表示服务器禁止访问资源。**404 Not Found**表示请求的资源在服务器上不存在或找不到，所以无法提供给客户端。

五类表示客户端发送的报文正确，但是**服务器处理的内部发生错误**，为服务器端的错误码。**500 Internal Server Error**也是笼统的错误码，表示不清楚服务器发生了什么错误。**501 Not Implemented**表示客户端请求的功能暂不支持。**502 Bad Gateway**表示服务器自身工作正常，但访问的后端服务器发生了错误*[即它作为网关或者代理在向另一个服务器请求数据时出错了，从上游服务器得到一个无效响应导致无法完成客户端的请求]*。**503 Service Unavailable**表示服务器当前很忙，暂时无法响应客户端。

③HTTP常见的字段

**Host字段：指定服务器的域名**。一个服务器常托管多个IP相同的网站，可以通过该字段区分客户端到底请求哪个网站。该字段是强制性的，如果没有该字段，服务器可以返回400错误。

**Content-Length 字段：表明本次响应的数据长度**。该字段作为HTTP body的边界，解决TCP粘包问题[回车、换行可以作为HTTP header的边界，也是解决TCP粘包问题]。

**Connection 字段：用于控制客户端和服务器之间TCP的连接**。close表示请求/响应后立刻关闭不再复用；keep-alive表示请求/响应后保持连接不断开以便后续复用，即要求服务器使用“HTTP长连接”机制。

**Content-Type 字段：用于告知客户端本次响应的数据格式**。表示的就是响应中的body数据格式，可以告诉浏览器如何解析和处理返回的数据，是前后端通信和网页加载中不可缺少的字段。

**Content-Encoding 字段：用于告知客户端服务器返回数据的压缩格式**。

#### 2 GET和POST

①GET和Post有什么区别？

答：**GET**[语义：从服务器获得指定资源]用于**获取资源**，参数体现在URL中，通常用于查询页面或获取资源；而**POST**[根据请求负荷(报文body)对指定资源做出处理]用于**提交数据**，参数在请求体中，适合传送大量或敏感数据，通常用于提交表单、上传数据、登录注册等。

另外，GET的参数长度是有限制的，主要是浏览器对URL长度有限制，HTTP协议本身对它没什么限制；而POST参数长度几乎无限，仅仅受服务器配置的限制。GET通常被保留在浏览器的历史记录中，而且可以被缓存；但POST不保留在历史记录中，默认也不会被缓存。GET方法是安全且幂等的；POST方法不安全也不幂等。

②GET和POST方法都是安全和幂等的吗？

答：从RFC规范定义的语义来分析，GET是安全且幂等的，它是“只读”操作，无论操作多少次，服务器上的数据都是安全且保持不变的；POST是不安全也不幂等的，它是“新增或提交数据”操作，会改变服务器上的资源，且多次提交会创建多个资源从而改变服务器状态。因此一般浏览器可以缓存GET请求还可以把它保存为书签，但不会对POST做这样的操作。

但实际过程中，开发者不一定完全按照上述规范实现GET或POST方法，所以不能完全确定两种方法始终安全和幂等。

【HTTP传输的内容都是明文的，为了避免传输过程中密码被窃取，就要采用HTTPS协议，使得所有HTTP数据被加密传输】

#### 3 HTTP缓存技术

①HTTP缓存有哪些实现方式？

答：**强制缓存和协商缓存**，强缓存让浏览器完全跳过服务器，协商缓存则会访问服务器确认资源是否更新。缓存主要是把重复性的“请求-响应”缓存到本地，下次直接读取本地数据，不再通过网络获取服务器响应。

②什么是强制缓存？

答：**浏览器在有效期内不访问服务器，直接使用本地缓存内容**。其判断依据主要是根据响应头的“Cache-Control”[浏览器第一次请求访问服务器资源时，会出现该字段设置过期时间大小]和“Expires”字段，前者优先级更高。一般浏览器发起请求后，发现还在有效期内就直接使用缓存，如果不在有效期内了就先不使用缓存，走协商缓存或重新请求[服务器再次收到请求后会重新更新CC字段]。

③什么是协商缓存？

答：**强缓存失效时，浏览器发送请求到服务器，服务器通过判断资源是否发生变化返回不同的结果**。若资源未改变则返回304并直接用本地缓存，若资源法神改变则返回200和新内容，同时更新缓存。其判断依据主要根据“If-Modified-Since”[要和Last-Modified字段进行比较，基于时间实现]和“If-None-Match”[基于唯一标识Etag实现，更可靠，避免由于时间篡改导致的不可靠问题]字段，后者的Etag优先级更高。

【为什么Etag优先级更高？】Etag是服务器根据每个资源的内容生成的哈希值唯一标识符，用于判断资源是否发生变化，只要内容发生改变，Etag就会发生变化，不受时钟影响，可以精确到1字节的内容变化。     ·即使没有修改文件，最后修改时间也可能会变化；·有些文件是在秒级以内修改的，If-Modified-Since可能捕获不到；·有些服务器不能精确获取文件的最后修改时间。

#### 4 HTTP特性

①HTTP/1.1的优点？

答：简单、灵活和易于扩展、应用广泛和跨平台。

**简单**-基本报文格式就是Header+body，头部信息也是key-value格式。

**灵活和易于扩展**-HTTP协议里的各类请求方法、状态码等都允许开发人员自定义和扩充。而且它工作在应用层，下层可以随意变化。

**应用广泛和跨平台**

②HTTP/1.1的缺点？

答：无状态、明文传输、不安全。

**无状态**-服务器不会用额外的资源记录HTTP的状态信息，但是在完成关联性操作时很复杂。解决方案之一-Cookie技术，通过在请求和响应报文中写入Cookie信息控制客户端状态。

**明文传输**-方便阅读和调试，但传输时信息不受保护易被窃取。

**不安全**-通信明文可能被窃听；不验证通信方身份有可能遭遇伪装；无法证明报文完整性有可能被篡改。

③HTTP/1.1性能如何？

答：长连接，管道网络传输、队头阻塞。

**长连接**-只要任意一端没有明确提出断开连接，则保持TCP链接状态，减少TCP连接重复建立和断开所造成的额外开销。不过如果超过一定时间没有任何数据交互的话服务器就会主动断开这个连接。

**管道网络传输**-在同一个TCP连接里，客户端可以发起多个请求，即请求可以并行。不过服务器必须按照接受请求的顺序进行响应。但是如果首位请求耗时长的话，后续会发生队头阻塞问题。

**队头阻塞**-“请求-应答”模式造成的，响应队头阻塞问题。

#### 5 HTTP与HTTPS

①HTTP与HTTPS有哪些区别？

答：HTTP是明文传输，存在安全风险问题；HTTPS在TCP和HTTP之间加入SSL/TLS安全协议，使得报文能加密传输。HTTP在TCP三次握手后就能进行传输；而HTTPS在三次握手后还需要进行SSL/TLS握手才能进行加密报文传输。两者默认发端口不一样，HTTP是80，HTTPS是443。HTTPS还需要向证书权威机构申请数字证书确保服务器身份可信。

②HTTPS解决了HTTP的哪些问题？又是如何解决的？

答：主要解决了HTTP明文传输中的窃听、伪装和篡改问题。通过引入TLS协议，使用对称加密保护数据的机密性，非对称加密和数字证书验证身份，摘要算法和MAC确保完整性，构建安全的传输通道。

**窃听**-窃取用户信息，用户账号丢失→信息加密

**伪装**-无法验证服务器身份，冒充正规网站→身份证书

**篡改**-数据完整性缺失，强制植入垃圾广告→校验机制

**混合加密**-对称加密+非对称加密，通信前采用非对称加密交换会话秘钥，后续传输过程全程采用对称加密明文数据。

**数字证书**-针对公钥也可能伪造的问题，引入数字认证机构，将服务器公钥放在数字证书中，只要数字证书可信，公钥即可信。

**摘要算法+数字签名**-计算机采用哈希函数计算出内容的哈希值，哈希值唯一且不可倒推。若哈希值与传输过来的不一致则表示内容可能被篡改。但这里存在一个问题，无法保证内容+哈希值是否被全部替换，即不能确定客户端收到的消息是来自于服务器。所以这里采用“私钥加密，公钥解密”的非对称加密方式对内容的哈希值进行加密，进一步确认消息的身份，确保消息不会被冒充。[公钥加密，私钥解密通常是为了确保内容传输的安全]

③HTTPS是如何建立连接的？其间交互了什么？

答：**HTTPS建立连接的核心是TLS握手的过程**。客户端和服务器先协商好协议版本和加密算法，服务器提供数字证书，客户端验证证书的合法性后生成对称密钥的前置信息并通过公钥加密发送。最终双方使用随机数和预主密钥共同生成对称密钥，完成握手进入加密通信阶段。

**Client Hello**-客户端支持的加密套件(支持的TLS版本、加密算法列表)+随机数

**Server Hello**-选定加密方案(TLS版本和加密算法) + 随机数2 + 数字证书(包含公钥)

**验证证书**-客户端检验证书的合法性(CA是否信任，是否过期，域名是否匹配)

**客户端生成对称密钥**-从数字证书中取出服务器公钥加密随机生成一个预主密钥(随机数3)发给服务器，服务器用私钥解密可以获得这个预主密钥

**双方计算最终会话密钥**-双方都根据两个随机数和预主密钥，通过一个协商好的加密算法生成本次通信的会话密钥

**握手结束**-双方发送对称加密的Finished报文确认密钥是否一致。后续就都采用会话密钥进行通信

【客户端是怎么校验数字证书的呢？】一方面，CA在签发数字证书的时候，会把持有者的相关信息打包进行哈希计算获得哈希值H1，然后CA用自己的私钥对H1加密生成一个签名，并添加在文件证书上。另一方面，客户端验证证书时，采用同样的哈希计算获得哈希值H1，然后使用CA的公钥解密签名的内容获得H2，比较H1和H2是否相同进而判断证书是否可信赖。[对于证书验证过程中的证书信任链问题，一般会先用根证书中的公钥验证中间证书是否可信，然后再用中间证书的公钥进一步验证网页证书是否可信。这样可以确保根证书的绝对安全性。]

④HTTPS的应用数据如何保证完整性？

答：**通过消息认证码保障数据的完整性。**在TLS中，所有的应用数据发送前要先通过密钥和哈希算法对数据本身计算一个MAC值作为消息认证码，附加到数据尾一并参与发送。接收方接到数据后用同样的密钥再计算一次MAC，与发送过来的MAC进行比较来判断是否被篡改。[TLS在实现上分为握手协议和记录协议，其中握手协议就是HTTPS建立连接的过程，记录协议负责消息的压缩、加密和认证]

⑤HTTPS一定可靠吗？

答：HTTPS能够有效防止窃听、篡改和伪装，极大地提升了通信的安全性，本身是没什么漏洞的。但如果还是受到攻击，通常情况下是利用了客户端的漏洞。无法防止用户访问**钓鱼网站**[用户自己不警惕，已经给出警告还执意要访问]、**证书伪造**[电脑中毒导致被恶意导入不被信任的根证书]、**系统漏洞**[浏览器或服务器本身的漏洞]或**加密配置错误**[使用了过时的协议版本或弱加密算法导致被破解]等问题。所以**HTTPS提供的主要是传输层的安全，而不是应用层的绝对保障**。

【为什么抓包工具能截取HTTPS的数据？】抓包工具能抓到的是加密的HTTPS数据，能解密是因为中间插入了“假证书”，相当于模拟中间人攻击。抓包工具要明文看到HTTPS的数据，类似充当中间人截取，一般需要拿到对应域名的私钥[去网站服务端拿，去CA拿域名的签发私钥，自己签发被浏览器信任的证书]。抓包工具能够抓包的关键就是客户端导入了受信任的自签证书，抓包工具给自己建立了一个CA[自己给自己当裁判]，即抓包工具在本地安装了一个自签名的“伪造证书”，把自己伪装成服务器劫持了HTTPS的握手过程，获取到加密前的数据，而浏览器被手动信任了假证书。

【那么如何避免被中间人抓取数据呢？】防止中间人攻击的关键是防止信任伪造证书。常见措施包括：客户端不安装不明来源的证书，确保服务器使用可信任的CA签发的数字证书，通过HTTPS双向认证双重验证双方身份，强制客户端只用HTTPS访问服务器防止降级，使用证书钉扎只信任特定公钥或证书，使用最新版的TLS避免旧协议漏洞。

#### 6 HTTP/1.1，HTTP/2，HTTP/3

①HTTP/1.1提升了什么性能？还有哪些瓶颈？

答：相比HTTP/1.0在**连接复用**[长连接避免频繁握手]、**管道化**[支持多请求并发减少等待时间]、**缓存控制**[引入Etag、Cache-Control字段，高效利用缓存减少重复请求]、**多网站托管**[强制Host字段可以同一IP托管多个网站]和**分块传输**[支持一边生成一边发送]等方面提升了性能，特别是默认开启长连接，避免了频繁握手带来的开销。但仍存在**队头阻塞**[响应必须按顺序返回可能堵车]、**多连接竞争**[没有请求优先级的控制，并发请求可能会导致TCP拥塞排队]、**慢启动**[数据传输初期TCP启动慢]和**头部冗余**[Header没有压缩就发送，头部信息越多延迟越大]等性能瓶颈，未能实现真正的并发与高效资源利用。

②HTTP/2做了什么优化？【**二多压推控**】

答：HTTP/2最核心的是引入了**二进制分帧和多路复用并发传输机制**[所有通信都拆成小的二进制帧，无需再把明文报文转成二进制而是直接解析增加数据传输效率；一个TCP连接里同时跑多个请求和响应互不阻塞]，使得多个请求可以服用一个TCP连接，解决了队头阻塞问题。另外通过**头部压缩**[重复头信息用字典压缩生成索引号]减少了冗余数据，**服务端推送**[服务端可以主动推送资源给客户端，减少等待，提前加载关键资源]提升响应速度，**流量优先级控制**[请求可以设置优先级，浏览器可以更灵活地控制资源加载的顺序]则提升了资源调度能力。

【HTTP/2的缺陷？】TCP队头阻塞问题仍然存在-虽然在应用层实现了多路复用，但仍然是基于单一的TCP连接。TCP层必须保证收到的字节数据是完整且连续的，这样内核才会把缓冲区的数据返回给HTTP应用。一旦底层丢包出发TCP的重传机制，TCP就得重传丢失的包，后面的字节数据就只能先放在内存缓冲区里，所有的并发请求就全都被阻塞了，必须等丢失的包重传回来再继续执行。

③HTTP/3做了什么优化？

答：它是在HTTP/2基础上做的一次底层协议更新，摒弃了传统基于TCP的传输方式，**改用QUIC协议**，通过**UDP**[不管顺序也不管丢包，所以不会出现TCP的队头阻塞问题]实现更高效的多路复用和连接管理，彻底解决了TCP的队头阻塞问题。且内嵌TLS1.3版本支持0-RTT建连，同时还具备连接迁移能力。

【QUIC协议的三大特点】**无队头阻塞**[多个Stream间相互独立，某个流发生丢包只影响他自己不影响其他流]；**更快的连接建立**[原本TCP和TLS握手分属不同的层不能合并。但QUIC内嵌了TLS，可以同时完成建立连接和密钥协商，甚至第二次连接时数据包还可以和握手信息一起发送]；**连接迁移**[TCP协议通过四元组(源IP、目的IP、源端口和目的端口)确定一条TCP连接，当网络切换时IP地址变化就必须断开重连。但QUIC通过连接ID标记通信的两个端点，即使IP变化了只要仍保有TLS密钥、连接ID等上下文信息就可以无缝衔接原连接]。总的来说，QUIC是一个在UDP之上的伪TCP+TLS+HTTP/2的多路复用协议。

【请详述HTTP/1.1和HTTP/2面临的队头阻塞问题】HTTP/1.1采用管道化的方式解决了请求的队头阻塞问题，但是**存在响应的队头阻塞问题**，如果某个请求响应时间太久的话只能等它响应完才能处理下一个请求。HTTP/2通过多路复用一个TCP连接解决了HTTP响应的队头阻塞，但是又**存在TCP层面的队头阻塞**，一旦丢包字节数据不完整就阻塞所有请求。

### 二、HTTP/1.1该如何优化呢？/如何优化一个慢页面在HTTP/1.1下的加载速度？

【做到：能不发不发，能少发少发，能快办快办】

答：HTTP/1.1 优化可以从多个维度出发。**连接层面**可启用 keep-alive 减少握手次数；**资源层面**可合并文件、启用压缩、精简请求头；**响应层面**设置合适缓存控制，避免重复请求【采用Cache-Control/ETag/Last-Modified等字段】；**加载层面**可使用懒加载或异步加载；**部署层面**则可利用 CDN 加速和域名分片提升并发能力。

三种常见思路：避免发送请求-缓存；减少请求次数-减少重定向请求次数，合并请求，延迟发送请求；减少响应数据的大小-压缩。

【如何减少重定向请求次数?】把重定向的工作交给代理服务器，通过一些重定向响应码实现。

【如何合并请求？】将多个访问小文件的请求合并成一个大请求，减少重复发送HTTP的头部，从而减少TCP连接的数量，省去TCP握手和慢启动过程耗费的时间。合并请求的方式就是合并资源，但是当某个小资源发生变化以后，整个完整的大资源就得重新下载，带来了额外的网络消耗。

【如何延迟发送请求？】采用“按需获取”的方式，即请求网页时仅获取当前所看页面的资源，滑动页面时再继续请求。

【什么是无损压缩？】适用于文本文件、程序可执行文件、程序源代码等。gzip为常见的无损压缩。首先将一些多余符号去掉，然后对原始资源建立统计模型，通过霍夫曼编码对常出现数据采用短二进制比特序列表示，不常出现的则用长二进制比特序列表示。

【什么是有损压缩？】适用于音频、视频、图片等多媒体数据。可以通过HTTP请求头中Accept字段里的“q质量因子”说明期望的资源质量。

### 三、HTTPS的RSA握手解析

1 TLS握手过程

通常经过“四个消息”就可以完成TLS握手，即2个RTT时延，然后就可以在安全的通信环境里发送HTTP报文实现HTTPS协议。

2 RSA握手过程

- 基本过程-TLS证书文件为服务端公钥，在TLS握手阶段传给客户端，私钥保持在服务端。客户端随机生成密钥并用公钥加密后传给服务端，服务端解密后双方再进行对称加密传输。
- TLS第一次握手-客户端say hello，主要是生成随机数A，并向服务器发送支持的TLS版本号和加密套件列表。
- TLS第二次握手-服务端say hello，主要是生成随机数B，并向客户端确认本次交互采用的TLS版本号和采用的加密套件。同时向客户端发送数字证书验证身份。
- TLS第三次握手-客户端再次生成一个随机数C，用服务器的公钥加密后传给服务器，服务器用私钥解密获得随机数C。然后双方根据三个随机数生成最终的会话密钥。客户端把此前消息进行摘要再用会话密钥加密，验证加密通信是否可用以及此前的握手信息是否被篡改。
- TLS第四次握手-服务端同样验证加密通信是否可用以及握手信息是否被篡改。此后双方就用会话密钥加密HTTP的请求和响应。

3 RSA算法的缺陷

最大问题：**不支持前向保密**。即一旦服务端私钥失窃，此前被截获的所有TLS通讯密文将全部被破解。

### 四、HTTPS的ECDHE握手解析

1 DH算法的数学基础-离散对数

【什么是离散对数？】
$$
已知y=b^x，求x=log_by，这是以b为底的y的对数，是普通的对数公式。已知y=b^x \quad mod \quad p，求x，只能暴力枚举。这就是模p意义下b的离散对数。p为质数。\\求解x时，只能枚举令b^x对p取余等于y，满足的就是要求解的x。
$$
现实中，DH会使用长达2048位的质数p使得暴力破解几乎不可能。因为p是2048位质数，需要尝试2^2048次，远超宇宙寿命。

因此，离散对数被认为在计算上是不可逆的，这种“单向易算，反向难解”的特性，正是各类公钥加密算法安全性的核心基础。

【离散对数是唯一的吗？】在模素数p的乘法群中，如果底数g是原根，则对任意可逆元y，都存在唯一的 x mod  (p−1)使得 g^x ≡ y mod  p。但如果 g不是原根，其生成的子群阶较小，可能存在多个解，甚至对部分 y无解。因此，是否唯一取决于g的阶和是否为生成元。通俗来讲就是，如果g不是原根，就会导致有些结果永远生成不出来，不能覆盖所有数字，这样构成的密钥空间就会有死角，密钥空间被缩小安全性就会降低使暴力破解变得容易。也就是说，假如一个数g是模数p的原根，就等价于：g^1，...，g{p-1} mod p生成了所有1,...,p-1的整数。

2  DH算法

基于离散对数先确定公开参数模数P和底数G，然后加密双方各自生成一个随机整数作为私钥分别记作a和b。然后双方分别计算公钥A=G^a (mod P)，B=G^b (mod p)，A、B同样可以公开。然后双方交换各自的公钥A和B，分别执行运算B^a (mod P)和A^b (mod P)将获得相同的结果K，即为双方的对称加密密钥，可以作为会话密钥使用。

![image-20250714205437572](C:\Users\tingtingtian\AppData\Roaming\Typora\typora-user-images\image-20250714205437572.png)

3 DHE算法

- static DH算法中有一方的私钥是静态的，通常是服务器固定，客户端随机生成。但是若截获海量密钥协商数据有可能暴力破解出会话密钥，则此前截获的加密数据都会被破解，该算法不具有前向安全性，已被废除。
- DHE算法，每次密钥交换通讯时，双方的私钥都是随机生成的。这样每次通信过程都是独立的，确保前向安全。

【RSA和static DH算法都不支持前向保密，他们有什么区别吗？】

答：二者都不支持前向保密，主要是因为他们都是用长期不变的私钥参与通信。RSA使用长期私钥解密对称密钥，而static DH使用长期私钥生成共享密钥。一旦私钥泄漏，历史通信内容就可能被破解。其中，RSA加密时，客户端获得服务器的公钥加密数据后，服务器用私钥解密；static DH加密时，服务器长期使用私钥a，客户端每次来都和它的g^b交换共享密钥。

4 ECDHE算法

DHE算法需要做大量乘法，计算性能不佳。因此ECDHE算法在其基础上，利用ECC椭圆曲线特性，可以用更少的计算量算出公钥和最终的会话密钥。

- 双方确定好本次通信采用的椭圆曲线类型，以及曲线上的基点G。
- 双方各自随机生成私钥a和b，并与基点G相乘获得公钥A=aG和B=bG。
- 双方交换各自的公钥，并分别计算点(x1,y1)=aB和(x2,y2)=bA，由于椭圆曲线上是可以满足乘法交换和结合律，因此aB=abG=baG=bA，即双方最终算出来的点是完全一样的。在实际应用中，通常只用x作为共享密钥。
- ![image-20250715110557826](C:\Users\tingtingtian\AppData\Roaming\Typora\typora-user-images\image-20250715110557826.png)

5 ECDHE握手过程

【ECDHE在TLS第四次握手前，客户端就已经发送加密的HTTP数据[因为此时已经协商完共享密钥，椭圆曲线提供了前向保密性可以确保安全性]，而RSA握手必须完成四次握手才能传输应用数据。因此ECDHE省去一个消息往返的时间，在连接尚未完全建立前就发送应用数据提升传输效率。】

- TLS第一次握手【与RSA完全相同】-客户端say hello，主要是生成随机数A，并向服务器发送支持的TLS版本号和加密套件列表。

- TLS第二次握手-服务端say hello，主要是生成随机数B，并向客户端确认本次交互采用的TLS版本号和采用的加密套件。同时向客户端发送数字证书验证身份。

  【与RSA不同的，服务器发送完数字证书后，还会向客户端发送本次通信使用的椭圆曲线、选定的基点G以及服务端椭圆曲线的公钥。】

- TLS第三次握手-客户端再次生成一个随机数C，用服务器的公钥加密后传给服务器，服务器用私钥解密获得随机数C。然后双方根据三个随机数生成最终的会话密钥。客户端把此前消息进行摘要再用会话密钥加密，验证加密通信是否可用以及此前的握手信息是否被篡改。

  【与RSA不同的，客户端生成客户端的椭圆曲线公钥并发送给服务端，然后双方根据各自的随机数A和B加上ECDHE算法算出的共享密钥x算出最终的会话密钥，后面就一样了。】

- TLS第四次握手-服务端同样验证加密通信是否可用以及握手信息是否被篡改。此后双方就用会话密钥加密HTTP的请求和响应。

### 五、HTTPS该怎么优化呢

1 性能损耗

【哪些步骤会产生性能消耗呢？】

答：**TLS协议握手过程，以及握手后的对称加密报文传输过程**。目前，对称加密传输过程性能消耗已经很小了，因此主要是TLS协议的握手过程增加了网络延时，以及握手过程中一些步骤产生性能损耗。主要是三个步骤：**双方产生椭圆曲线公私钥，客户端验证数字证书时访问CA，双方计算对称加密密钥时**。

2 硬件优化

【什么是计算密集型和I/O密集型？】计算密集型主要消耗CPU资源，计算能力更强，比如大数据处理、图像渲染、压缩加密等；I/O密集型主要消耗磁盘、网络等输入输出型资源，读写能力更强，比如读写大量日志数据库、爬虫请求网页、下载上传文件，是CPU等待硬盘、网络等设备返回数据的任务。

HTTPS连接过程中有大量计算密钥的过程中，因此属于计算密集型，应选择可支持AES-NI特性的CPU。

3 软件升级

4 协议优化

①密钥交换算法优化

采用ECDHE算法，响应快而且安全性也高，最好选择x25519曲线计算最快。

②TLS升级

采用TLS 1.3，大幅简化握手步骤。*双方直接在say hello的信息里带上要商定的椭圆曲线和对应的参数以及公钥*。

5 证书优化

①证书传输优化

减少证书大小就可以节约带宽，减少客户端运算量。因此可以选择椭圆曲线证书(ECDSA)代替RSA证书，用更短的密钥长度就可以达到相同的安全强度。

②证书验证优化

【客户端验证证书要做哪些工作？】走证书链逐级验证，一方面用CA公钥解密证书，另一方面用签名验证证书的完整性。此外还会访问CA，通过CRL[证书吊销列表，由CA定期更新，但存在实时性较差以及下载速度慢和全程遍历问题]或OCSP[在线证书状态协议，向CA发送请求验证其有效状态，但依赖于CA服务器的响应情况]确认证书的有效性。

采用OCSP Stapling方法，服务器周期性地向CA查询证书有效状态，获得带有时间戳和签名的响应并缓存。*这个缓存结果可以在TLS握手的过程中就传递给客户端，避免客户端向CA查询*。

6 会话复用

①对首次TLS握手协商的对称加密密钥进行缓存，用于后续的复用，可以减少TLS握手的性能损耗。可以分为**Session ID和Session Ticket**两种。

②Session ID

双方首次建立连接后，会在内存缓存会话密钥并用Session ID进行key-value标识。然后*下次say hello时直接带上这个标识，只用一个消息往返就能就建立安全通信*。但是为了安全起见，这个会话密钥还是会定期失效。

存在两个问题：服务器内存压力会比较大；对于集群服务器负载均衡地提供服务，客户端不一定就能选中上次连接的服务器，还得走TLS握手流程。

③Session Ticket

服务器不再缓存密钥，而是由客户端进行缓存。双方首次建立连接后，服务器加密会话密钥发送给客户端作为Ticket进行缓存。下次连接的时候客户端直接发送这个Ticket作为入场券，服务器验证没问题就直接加密通信。对集群服务器要确保所有服务器加密会话密钥的密钥是一致的，确保客户端来的时候从哪个门进都可以。

【但是二者都不具备前向安全性，而且应对**重放攻击**也很困难】

④重放攻击

答：指攻击者把合法用户发送过的有效数据包或请求拦截下来，原封不动地重新发送一次或多次骗过接收方。他不篡改内容，而是复制粘贴已发送的内容冒充新请求。目的是欺骗系统、伪装身份。一般可以给会话密钥设定一个合理的过期时间来避免这一问题。

⑤预共享密钥

原理和Ticket类似，但是重连时客户端直接把Ticket和HTTP请求一起发给服务端。

### 六、HTTP/2的优势是什么？【二多压推控】

1 兼容HTTP/1.1

【如何做到兼容的？】①没有引入新的协议名，很好地实现了协议的平滑升级。②仅仅在应用层做了改变，语义规则保持不变，而是在语法层面进行改造，主要是改变了HTTP报文的传输格式。

2 头部压缩

【存在问题】HTTP协议的报文是“Header+Body”格式，HTTP/1.1可以压缩Body部分，但是**不能压缩Header**。而Header通常包含大量固定字段，且很多请求和响应的Header字段值重复，另外字段采用ASCII编码效率很低。

【解决方案】**开发HPACK算法**，包括**静态字典**[包含61中高频出现在头部的字符串，编码格式：01静态表中的Index(01表示字段属于静态表范围且value变化)+1value长度(1表示经过H编码，另外这个长度还可以用来分割Index和value，因为没有冒号空格作为分隔符了)+经过H编码的value串]、**动态字典**[不在静态范围内的头部字符串，通常首次发送时双方会更新动态表，下次发送则仅仅发送Index号即可，但是也有一个数量上限，达到上限后会关闭HTTP/2连接来释放内存]和**Huffman编码**。双方建立和维护字典，用长度较小的索引号表示重复字符串，再用H编码压缩。

3 二进制分帧

【解决方案】将文本格式改成二进制格式极大提高了传输效率。

一条HTTP响应分为Headers帧和Data帧进行传输。

【二进制帧的结构】帧头+帧数据。其中帧数据包括经过HPACK压缩的头部和包体。帧头由：**帧长度**(3个字节)、**帧类型**(数据帧和控制帧)、**标志位**(携带简单的控制信息，类似头数据结束、**优先级**、单向发送结束等)和**流标识符**(从乱序帧中标识相同Stream ID的帧并有序组装信息)构成。

4 多路复用并发传输

【存在问题】HTTP/1.1通过管道化方式解决请求队头阻塞问题，但存在响应队头阻塞问题，只能完成一个事务才能处理下一个事务。

【解决方案】**多个Stream复用一条TCP连接**达到并发效果，提升HTTP传输的吞吐量。

一个TCP连接包含多个Stream；一个Stream包含多个Message，Message对应请求或响应，由HTTP头部和包体构成；一个Message包含多个Frame。同一个HTTP的请求-响应对要在同一个Stream中。

不同Stream的帧可以乱序发送，因为大家都在帧头部分带了流标识符。但是同一个Steam里的帧要确保严格有序。

客户端的Stream都是奇数号的，服务端的Stream都是偶数号的。

同一连接的Stream ID不可复用，如果达到上限需要通过控制帧GOAWAY关闭TCP连接。

5 服务器主动推送资源

【推送怎么实现的？】客户端发起Stream1的请求后，服务端在响应Stream1时先发送PUSH_PROMISE帧，通过Promised Stream ID字段告知客户端会在后续哪个响应中推送相应资源。注意这个帧是独立的控制帧，它虽然也放在原请求通道上，但不是放在Stream1的响应体里，因为响应体是纯数据，不能用来控制帧传输行为。实际推送的资源将在服务器新分配的Stream中发送。

### 七、HTTP/3的优势是什么？

1 HTTP/2的局限性

答：TCP队头阻塞，TCP[三次握手]与TLS握手[四次握手]延迟，网络迁移时需要重新连接。

【为什么HTTP/2网络迁移时需要重新连接？】因为一个TCP连接由四元组(源IP、目标IP和源端口、目标端口)共同确定，如果IP地址或端口变动了，TCP和TLS就必须得重新握手，这是不利于移动设备切换网络场景的。

2 QUIC协议的特点

HTTP/3将传输协议换为UDP，且基于UDP协议在应用层实现QUIC协议。UDP包之间无序且没有依赖关系，而且不需要连接，无需握手挥手过程，因此速度快于TCP。

① **无队头阻塞**

可以在同一条连接上并发传输多个Stream。QUIC协议会确保数据包的可靠性，每个数据包都通过序号进行唯一标识。由于各个Stream独立，因此即使某个Stream丢包也不影响其他Stream，也就不存在队头阻塞问题。

② **更快的连接建立**

以前的协议TCP和TLS是分层的，因此要分批次握手，先TCP，再TLS。

而QUIC协议内部包含TLS，在自己的帧里会携带TLS，仅需1RTT即可同时完成建立连接与密钥协商，第二次连接时，数据包还可以和握手信息(建立连接+TLS)一起发送，达到0RTT效果。

③ **连接迁移**

QUIC协议没有用四元组方式确定连接，而是通过连接ID标记通信的两个端点，这样即使网络变化IP地址变化，只要仍保有上下文的连接ID和TLS密钥等，依然可以无缝复用原连接，而不用重连。

3 HTTP/3协议

①【**HTTP/3的帧头里只包含类型和长度**，消除了流标识符和标志位，为什么呢】

答：因为HTTP/3是构建在QUIC上的，QUIC协议天然就是多流协议，本身就内置了多路复用每个Stream相互独立，它发送在哪个QUIC Stream上就属于哪个Stream，不需要再区分。而HTTP/2建立在TCP上，TCP本身是一个单一的字节流，需要人为的多路复用，所以必须通过显式携带流标识符才能实现。

HTTP/3把标志位的职责分散到了QUIC Stream的结束语义[直接关闭QUIC Stream就行]、状态码放到HTTP的header中完成了，这样就不再依赖帧头标志位了。

总结来说：HTTP/2中帧作为逻辑控制单位，很多事都要靠帧的控制字段完成。而HTTP/3的QUIC协议自带流控制和生命周期管理，HTTP只需要定义语义帧的类型就行，把很多复杂的控制职责下放到了QUIC层，简化了HTTP层。

②HTTP/3的头部压缩算法从HPACK升级成QPACK

**静态表**-从61项扩大到91项

**Huffman编码**没有变化

**动态表**-原来的动态表具有时序性，首次请求-响应后先更新各自的动态表后续再用1个数字表示，但是如果首次请求的时候丢包了，后续再请求的时候就没法解码，必须阻塞到首次请求的丢包重传过来。

QUIC设计了两个单向流，编码流(QPACK Encoder Stream)用于将字典传给对方，解码流(QPACK Decoder Stream)用于响应对方，告知对方字典已更新到本地动态表。这样就可以同步双方的动态表，编码方只有收到更新确认才会用动态表进行编码。

### 八、既然已经有HTTP协议，为什么还要有RPC？

答：**HTTP是一种非常通用的低层通讯传输协议**，主要用于客户端和服务端的通信，比如访问网页、接口等。但是对于系统间的通信，更希望像调用本地函数一样调用远程服务，**RPC(Remote Procedure Call)就是这种更高级别的调用方式**。RPC像写本地代码一样调用远程函数，隐藏了很多类似请求头处理的底层细节。而且RPC框架支持自动代码生成、高效的二进制传输和统一的接口描述文件，能够提高开发效率和提升性能。总的来说，RPC更适合服务与服务间的高效、结构化调用，可以选择基于多种协议。

①使用TCP有什么问题？

**TCP三个特点：面向连接、可靠、基于字节流。**

由于TCP的字节流特性，其发送数据流时没有任何边界，可能产生粘包问题。因此有必要加入一些自定义规则用来区分消息边界。这就用到消息头，消息头里会包括数据包长度、数据压缩格式、消息格式等等，需要上下游约定好的协议。因此每个使用TCP的项目都会基于一些协议，比如HTTP、RPC。

②HTTP和RPC

**TCP是传输层协议，HTTP和RPC是定义了不同消息格式的应用层协议**。

RPC又叫做远程过程调用，本身并不是一个具体的协议，而是一种调用方式。类似gRPC、Thrift这样的具体实现才是协议，他们是实现了RPC调用的协议。目的是希望程序员能像调用本地方法一样调用远端的服务方法。举个例子，如果我们调用的一个方法不是本地方法，而是远端服务器的方法，RPC就可以屏蔽掉一些网络细节，像调用本地方法一样直接调用这个方法。

多年前，HTTP主要用于浏览器/服务器架构(不仅访问自家服务器，还要访问其他公司网站服务器)，RPC更多的用于客户端/服务端架构(通常只访问自家服务器)。

③HTTP和RPC的区别

**服务发现**[即寻找服务对应的IP端口的过程]-HTTP知道服务的域名就可以通过DNS解析获得IP地址，默认80端口；RPC一般有专门的中间服务保存服务名和IP信息，直接通过中间服务获得IP和端口信息就行。

**底层连接形式**-通常HTTP长连接形式之后的请求和响应都会复用这条连接；而RPC虽然也会建立长连接，但是会再有一个连接池，请求量较大时，会建立多条连接放在连接池内，用完放回还可复用，非常环保。连接池有利于提升网络的请求性能。

**传输的内容**-HTTP的包体通常用Json序列化*[把结构体转化为二进制数组的过程]*结构体数据，一般内容比较冗余；RPC一般定制化程度较高，采用体积更小的Protobuf或其他序列化协议去保存结构体数据，性能会更好。

### 九、既然已经有HTTP协议，为什么还要有WebSocket？

答：**HTTP是一种请求-响应模式的协议**，客户端必须先发起请求，服务器才能返回数据。这种模式不适合实时性很强的场景，比如即时通讯、直播、数据推送等，这种模式服务器没办法主动推送消息给客户端。**WebSocket则是一种建立在HTTP之上的双向通信协议**，一旦握手成功客户端和服务端之间保持长连接，双方就可以随时主动发送数据，通信更高效和实时，避免了HTTP的轮询、延迟等问题。总的来说，HTTP满足基本的网页交互，但WebSocket更适合低延迟、高实时的应用。

另外WebSocket的数据帧更轻量，不再使用HTTP的头部格式，传输开销小。虽然HTTP/2也支持一定程度的服务器推送，但还不是真正意义上的双向通信【HTTP/2的服务器推送是被动触发的，仍然是客户端先发送请求，服务器才顺带推送。本质上仍是以客户端为驱动的通信协议，它不能主动发消息，只能在响应客户端某次请求时顺便推送】。

1 HTTP的轮询是什么？

**存在问题**-解决HTTP不能实现服务器主动发消息给客户端的场景，关键点在于，如何才能在用户不做任何操作的情况下，网页就能收到消息并发生变更。

**解决方案**-网页的前端代码不断定期请求服务器，服务器收到请求后给客户端响应消息。实际应用场景：扫码登录。

**弊端**-消耗带宽，增加下游服务器负担；不能即时触发，会存在卡顿的情况。

2 长轮询

**是什么**-长轮询是一种让客户端**“伪装成实时通讯”**的HTTP技术手段，服务端有新数据时才返回响应。换句话说，就是客户端发起一个请求，在较长时间内等待服务器响应的机制。【固定频率发送请求为普通轮询，发送后服务器马上返回即使没有数据也返回；而客户端发送请求后始终等待，直到服务器有数据才响应就是长轮询；WebSocket双方一次连接后就保持双向通讯，可实时推送。】

**实例**-客户端发起请求后，服务端并非立刻返回而是挂起请求，直到有新数据变化或请求超时。服务器返回数据后，客户端马上再发起新请求。从而形成“实时”体验。比如扫码登录场景，长轮询就是核心通信机制。

**局限性**-每次请求都是一个新的HTTP连接，消耗比WebSocket要大，但确实减小了HTTP请求个数；对服务端压力较高，需要设置比较合理的超时时间。

3 WebSocket是什么？

全双工-TCP连接两端，同一时间内，双方可以主动向对方发送数据。

半双工-HTTP/1.1同一时间里，只能有一方主动发送数据。

**设计动机**-满足需要双方互相主动发送大量数据的场景，如页游。

①如何建立WebSocket连接？

答：这是一个**从HTTP握手升级为WebSocket协议的过程**，HTTP建立连接成功后才变成“全双工的持久连接”。换句话说，通过一次HTTP请求握手，然后“升级协议”建立连接。具体步骤如下：

**客户端发起带升级标志的HTTP请求**-包括Upgrade、Sec-WebSocket-Key/Version等字段表明发起请求，以及用于校验的随机字符串。

**服务器响应确认协议升级**-状态码101 Switching Protocols 表示服务器同意协议升级。Sec-WebSocket-Accept为服务端加密计算的校验值来验证身份。

**握手成功完成协议升级**-后续双方均切换到WebSocket协议开始双向通信。

②WebSocket的消息格式-仍为消息头+消息体格式

几个重要字段：

**opcode**-标志数据帧类型，1-text类型的string数据包；2-二进制类型的byte数据包；8-关闭连接。

**payload**-存放真正被传输的数据长度，单位是字节。一般读取的时候先读7个bit，然后根据取值决定后续用哪些版本的字段存放payload。

**payload data**-存放真正被传输的数据



## TCP篇

### 一、TCP三次握手与四次挥手面试题

#### 1 TCP的基本认识

①TCP头格式有哪些？



②为什么需要TCP协议？TCP工作在哪一层？



## IP篇

### 一、IP基础知识全家桶

#### 1 IP的基本认识

IP处于网络层，网络层主要实现主机与主机之间的通信，也叫点对点通信。而**IP的作用是在复杂的网络环境中把数据包发送给最终的目的主机**。

①网络层(IP)和数据链路层(MAC)之间的区别和联系

**作用不同**-IP的作用是主机之间通信，在没有直连的两个网络间进行通信传输；MAC的作用是实现已经直连的两个设备间的通信。

**作用范围不同**-MAC只负责某个区间之间的通信传输，而IP负责将数据包发给最终的目的地址。

**地址变化不同**-源IP和目标IP在传输过程中保持不变，而源MAC和目标MAC一直在不同设备间中转，所以一直变化。

#### 2 IP地址的基础知识

IPv4地址由32位正整数表示，**在计算机以二进制方式处理**。采用**点分十进制**的标记方式，8位一组共分4组，每组用·隔开，再每组转换成十进制。

【补充知识-什么是网卡】

答：通俗来讲，网卡是一种硬件，用来让电脑连接网络，相当于电脑的网络身份证和连接互联网的插口。它负责把电脑里的数据翻译成网络能传播的形式再通过网线或无线传出去。换句话说，**网卡是电脑/手机等设备与网络之间的桥梁，有唯一的身份MAC地址，负责数据在物理网络上的传输**。网卡的功能：**收发数据**-*[把计算机的数据转换成网络信号发出，把网络上的数据接收传给操作系统]*、**识别设备身份**-*[每个网卡有一个唯一编号MAC地址作为它在局域网的身份证]*和**参与底层的通信协议处理**-[负责数据链路层帧的收发和校验]。

##### ①IP地址的分类

首先，IP地址分为A/B/C/D/E五种类型，根据首位、次位、三位、四位等是否为0判断属于哪一类，如果都不是，那就属于E类。

【什么是A/B/C类地址？】

答：A/B/C类分为网络号和主机号，主机号分别为3个8位、2个8位和1个8位，即A类1到127，B类128到191，C类192到223。每类最大主机个数就用2的(3×8、2×8、1×8)次方-2，把主机号全为1*[指定某个网络下所有主机，用于广播]*和全为0*[指定某个网络]*的IP去掉。

【什么是D/E类地址？】

答：D/E类没有主机号，不可用于主机IP，D类一般用于多播，E类是预留的分类，暂时没有使用。

【广播和多播地址分别用于什么？】

答：**广播地址是发给某网段中所有主机的特殊IP地址，用于在同一链路中相互连接的主机间发送数据包**。分为**本地广播和直接广播**。其中本地广播不依赖于IP地址和子网掩码，仅在当前本地网络中有效，不会被路由器转发到其他链路上，一般用在初始阶段，比如DHCP请求获取IP地址的时候。直接广播的地址包括子网地址+主机地址全1，可以通过路由器转发给特定子网中的所有设备，但需要知道明确的子网[存在一定的安全问题，一般被禁]。

**多播地址用于把包发给特定组内的所有主机**，节省带宽但需要接收者自己加入这个组。多播采用D类地址，前四位是1110，后28位是其组编号。一般用在视频会议、直播，在线游戏同步位置、状态等。从224.0.0.0到239.255.255.255，其中前255个是本地网络多播，只能用在局域网中不经过路由器；239.0.0.0-239.255.255.255是私有多播，仅限内网内部使用，只在特定本地范围内有效；中段的是用户可用的多播地址，可路由多播和跨网段使用。

【IP分类的优势和局限性】

答：优势就是简单明了、选路简单，很快就能找到网络和主机地址。

局限性：同一网络下没有地址层次，缺乏地址的灵活性；不能很好地与现实网络匹配，ABC类地址多的太多了，少的又太少了。

##### ②无分类地址CIDR

**表示形式**-a.b.c.d/x，这里的x表示前x位属于网络号。

**子网掩码**-掩盖掉主机号，剩余的就是网络号，比如10.100.122.2/24的子网掩码就是255.255.255.0。子网掩码和IP地址与运算就是网络号。[计算网络号是为了判断是否在同一网段，从而决定数据是直接发送还是通过路由器转发]

【为什么区分网络号和主机号？】

答：网络号表示你在哪个子网，主机号表示你在这个子网的哪台主机。便于路由器寻址，可以通过找到对应的网络号，把数据包转发到对应的网络内。

【子网掩码对子网的划分】

子网掩码可以进一步把主机地址分成**子网网络地址和子网主机地址**。比如在一个C类地址里，主机号有8位，我们借用前2位作为子网内部的子网号，最后6位用于分配主机。

##### ③公有IP和私有IP

公有IP可以在互联网上直接被访问，且全球唯一。

私有IP只能在局域网内使用，不能直接访问互联网，局域内唯一全球范围内可重复。

【家里设备上网用的是私有IP，如何访问互联网呢？】

答：通过**NAT技术(网络地址转换)**，路由器有一个公网IP，当家用设备需要访问互联网时，路由器就会把私有IP转换成公网IP发送出去，在互联网看来就是这个公网IP进行了访问。

##### ④IP地址和路由控制

IP地址的**网络地址用于路由控制**，即帮助路由器导航。

主机和路由器上都有各自的路由器控制表，记录了网络地址和下一步应该发送的路由器地址。

如果表中存在多条相同网络地址的记录，就匹配相同位数最多的网络地址。如果表中找不到与目标地址相同的网络地址，就把包转发到默认路由。

**特殊IP地址环回地址-127.0.0.1**，计算机网络用于主机自身通讯的一种特殊IP地址，即同一计算机程序间进行网络通信时使用的默认地址，它与localhost主机名一样，数据包都不会流向网络。一般可以用来测试TCP/IP协议栈是否正常工作，ping不通的话就是本机网络协议栈出问题了；本机内部通信，不需要经过真实网卡或网络传输；其绑定的服务只能本机访问，不会暴露到局域网或公网，也可用于开发调试。

##### ⑤IP分片与重组

每种数据链路使用目的不同，其的最大传输单元MTU也不同。通常以太网的是1500字节，超过的话就要分片，最终由目标主机再重组起来。

传输的时候一旦某分片丢失，该IP数据就报废了，所以TCP引入MSS在TCP进行分片避免IP层分片。UDP的话尽量不要发送大于MTU的报文。

##### ⑥IPv6的基本认识

**优势**-**即插即用**，即使没有DHCP服务器也可以自动分配IP地址；**提升传输性能**，简化首部结构去掉包头校验和；**提升安全性**，具备应对伪造IP地址和防止线路窃听的功能。

**标识方法**-共128位，16位一组，采用十六进制表示，其间用冒号隔开。而IPv4是32位，8位一组，采用点分十进制表示。

**单播地址类型**-**链路本地单播地址**，同链路单播通信，不经过路由器；**唯一本地地址**，内网单播通信，类似IPv4私有IP；**全局单播地址**，互联网通信，类似IPv4公有IP。

##### ⑦IPv4和IPv6的首部比较

**长度**-IPv6是固定长度40字节，取消了一些可选字段，简化了路由器处理流程。IPv4一般是20-60字节。

**消除的字段**-**首部长度**[固定长度，不需要这个字段]；**标识、标志、偏移**[不在首部处理分片，而是在源和目标主机进行，大大提升路由转发速度]；**校验和**[由链路层或传输层保证完整性，提高效率]

**特有字段**-**流标签**[用来标识同一流的数据包]；**扩展头部机制**[通过路由头、认证头等链式扩展，模块化强]

#### 3 IP协议相关技术

##### ①DNS域名解析

DNS可以将域名网址自动转换为具体的IP地址。

**域名的层级关系**-域名通过句点分割，越靠右层级越高。**根→顶级域→权威DNS服务器**

**域名解析工作流程**-客户端发起DNS请求询问IP地址并发送给本地DNS服务器→本地DNS服务器先查询缓存，再询问根域名服务器获得顶级服务器地址→再从顶级服务器这里获得权威服务器地址→权威服务器查询后将IP地址告知本地DNS服务器→本地DNS将IP地址返回客户端，客户端和目标建立连接。

##### ②ARP和RARP协议

ARP协议可以获得下一跳的MAC地址；RARP协议可以通过MAC地址求得IP地址。

**ARP协议**-**借助ARP请求与响应确定MAC地址。**主机通过广播发送ARP请求询问已知IP地址的MAC地址；同链路所有设备收到请求后进行对比查询，与之相同的设备将自己的MAC地址塞入ARP响应包返回给主机。

**RARP协议**-**通过架设RARP服务器实现。**在该服务器上注册设备的MAC地址和IP地址，设备发送请求后RARP服务器会把相应注册信息返给设备。一般用在把打印机等小型嵌入式设备接入网络。

##### ③DHCP动态获取IP地址

DHCP（Dynamic Host Configuration Protocol，动态主机配置协议）是一个**自动为网络中的主机分配IP地址及相关网络配置信息**（如网关、子网掩码、DNS等）的协议，主要用于简化网络管理，避免手动配置出错。

DHCP动态分配IP的过程如下：DORA——Discover、Offer、Request、Acknowledge

**Discover**-新接入网络的主机（客户端）以广播方式发送“DHCP Discover”消息，寻找DHCP服务器。

**Offer**-DHCP服务器收到请求后，从地址池中选一个IP地址[这里要搭配一些子网掩码等的附属信息]，并发送“DHCP Offer”消息给客户端。

**Request**-客户端从收到的一个或多个服务器中选择一个，向该服务器发送“DHCP Request”请求，希望租用该IP地址。

**Acknowledgement**-服务器发送“DHCP ACK”确认消息，并正式分配IP地址。客户端就可以使用该IP了。

【除了IP地址，DHCP还同步发送子网掩码、默认网关、DNS服务器的地址以及租约时间，租约时间到期后可以续约，也可以选择始终分配固定IP】

【整个交互过程采用UDP广播通信，当DHCP服务器和客户端不在一个局域网，就由DHCP中继代理应对不同网段的IP地址分配】

##### ④NAT网络地址转换

NAT作用-在私有网络(家用等)和公有网络(互联网)间进行IP地址转换，实现多个私有设备共享上网。

NAPT-不但转换IP地址，且转换端口号，可实现多个内部设备通过同一个公网IP访问互联网，通过转换后的端口号进行区分。

转换表在NAT路由器上自动生成，收到关闭连接的信号时再删除。

**NAT局限性**-外部无法主动与内部服务器建立连接；转换表的生成与转换都会产生性能开销；若NAT路由器重启，则所有TCP连接都要重置。

**解决方案**-改用IPv6彻底不需要NAT；NAT穿透技术[一种可以让NAT后的两个主机直接建立连接的手段，即设备自己建立端口映射条目]。

##### ⑤ICMP互联网控制报文协议

**主要功能**-确认IP包是否成功送达目标地址；报告发送过程中IP包被废弃的原因；改善网络设置。

**类型**-用于诊断的**查询报文**；通知出错原因的**差错报文**。

##### ⑥IGMP因特网组管理协议

**是什么**-用于管理IP多播组成员关系的协议，主要运行在主机与直接相连的多播路由器之间，用于IPv4中主机告知路由器是否加入或退出某个多播组。

应用场景-视频会议、多人在线游戏。

主要版本-IGMPv1[主机只能加入不能显式离开]/v2[增加离开祖通知]/v3[可指定接收或屏蔽某些源发来的组播]

**工作流程简要**-**加入组**[主机请求加入某个组]→**组查询**[路由器定期查询是否有主机在收听某组]→**离开组**[主机发送离开报文并通知路由器不再接收该组数据]→**路由器维护组表**[根据组查询后的主机反馈决定是否继续转发某组数据到该网段]【如果某个主机A从某个组B走了，路由器就会问一下我们这个网段还有没有别的主机在组B，如果还有主机C响应这个询问的话，路由器就还转发组B的内容；如果一定时间后都没有主机响应就表示组B里已经没有我们这个网段的成员了，也就不再转发组B的内容】

### 二、ping的工作原理

答：ping作为常用的诊断工具通常用于测试两台主机之间的连通性，也可以测试网络延迟、检查网络是否存在丢包、验证目标主机是否在线等，**底层依赖的是ICMP协议的查询报文类型，主要通过回送请求和回送应答报文**。

1 ICMP协议-IP协议的助手

**包头格式**-工作在网络层，是IP协议的助手。**IP头+ICMP报文=IP数据报文**。

2 查询报文类型

用途-检查网络是否连通，ping的工作原理。

回送请求-类型8；回送应答-类型0。

**重要字段**-**标识符**[区分谁发出了请求，采用PID作为标识符]；**序列号**[从0开始，每发送一次新的回送请求就加1，确认网络包是否有丢失]。

3 差错报文类型

用途-在网络中传达各种错误信息，帮助主机或路由器了解发送或转发IP数据包时出现的问题。

**3-目标不可达消息**：IP路由器无法把数据包发送给目标地址，通过一个ICMP消息告知发送端主机，并且把不可达的原因记录在ICMP包头的代码字段。【0网络不可达，路由器表匹配不到接收方IP的网络号；1主机不可达，路由表中没有该主机或主机没有连接到网络；2协议不可达，双方协议不匹配或使用了非法协议编号，极少见；<u>3端口不可达</u>，某个端口直接关闭或没有相应进程监听端口；<u>4需要分片但设置了不分片</u>，发送的数据包禁止分片，遇到的路由器发现数据包超过MTU就不分片直接丢弃】

**4-原点抑制消息**：要求发送方降低发送速率，早期用于控制拥塞的手段，已弃用。

**5-重定向消息**：告知主机数据包发送的最优路由路径，包含最恰当的路由信息和源数据。

**11-超时消息**：当IP包中的TTL(Time to live，生存周期)数值为0时，该IP包被丢弃，会通过该消息告知发送端主机该IP包传输超时。避免路由控制发生状况陷入死循环后IP包还无休止地被转发。【0TTL超时；1数据报组装超时，分片重组失败】

4 查询报文类型的使用：ping

**发送**-**源主机<u>构建ICMP回送请求</u>数据包**，包含类型*[8]*、序号*[标识请求顺序]*和发送时间*[计算往返时间]*→**IP层获得目标地址且已知本机源地址**，协议字段设置为1表示ICMP协议→**通过ARP协议获得MAC地址**，由数据链路层构建一个数据帧

**接收**-目标主机收到数据帧→**检查MAC地址**是否和本机匹配→**提取IP数据包**→**提取有用信息交给ICMP协议**→**<u>构建ICMP回送响应</u>数据包并发送给源主机**，类型[0]

规定时间内源主机收到回送响应消息，比对两个发送时间相减即为ICMP数据包的时间延迟。

5 差错报文类型的使用：traceroute

**故意设置特殊TTL**-追踪去往目的地沿途经过的路由器。通过递增顺序设置IP包的TTL字段，并发送UDP包强制接收超时消息，如此往复就可以拿到途径所有路由器的IP。【怎么确认UDP包有没有到达目的主机？通过“端口不可达”类型，借用不可能的端口号作为目标端口号，这样目的主机收到UDP包以后就会告知源主机端口不可达，从而证明UDP包到达了目标主机】

**故意设置不分片**-确定路径的MTU。发送端主机发送IP数据报时，把分片禁止标志位设成1→借用3目标不可达消息类型的代码4把数据链路上的MTU值一并发回给主机→发送端每次接收到差错报文就减少包的大小，最终定位一个合适的MTU值。

### 三、断网后是否还能ping通127.0.0.1

1 什么是127.0.0.1

它是一个回环地址，指向本地计算机自己，常用于测试自己机器的网络功能是否正常使用。

127开头的都属于回环地址，也是IPv4的特殊地址。

IPv6的ping命令是ping6 ::1【为什么不是7个冒号，因为IPv6只允许一次出现两个连续冒号】

2 什么是ping

3 TCP发送数据和ping的区别

①相同-ping数据和其他应用的TCP数据都处于应用层；且传输数据时都要用到socket并创建；二者进入内核态后都要调用sock_sendmsg方法

②不同-**TCP数据的Socket创建在传输层工作**，使用sock_stream表示使用面向字节流的TCP协议，然后通过sendto接口从用户态进入内核态；**ping数据的Socket创建在网络层工作**，使用sock_raw表示使用ICMP协议。

4 为什么断网后也能ping通127.0.0.1呢？

答：因为①**该IP地址不走外部网卡或网络**，完全在本机内部运行，不经过物理网卡或访问外部网络；②**仅仅是用于检测TCP/IP协议栈是否正常**，比如IP层、路由表、ICMP等；③操作系统内核虚拟出一个接口作为“本地网卡”，始终存在但**不依赖真实的网络设备或连接**。

信息传输的时候在网络层会查询路由表，确定目标IP的数据从哪个网口发出，如果是回环地址的话，就会选择本地网卡这个虚拟接口。这个虚拟接口会把数据放在input_pkt_queue链表中，然后触发软中断，由内核线程ksoftirqd去链表中把消息取出，重新顺着数据链路层、网络层等返回给应用程序。

5 ping回环地址和本机IP有区别吗？

答：没有区别，都是走Io0本地回环接口，数据不发往网络，仅仅经过本机网络协议栈。

6 127.0.0.1和localhost还有0.0.0.0有区别吗？

①127.0.0.1：回环地址，表示本机自身，不经过真实的网络接口卡，直接在内核协议栈处理，用于检查本地网络协议栈是否正常

②0.0.0.0：非合法目标/特定地址，不能直接作为目标IP进行通信，但可以监听本机所有可用的网卡地址，属于默认路由表示本机的所有IP地址【ping这个是ping不通的，在IPv4里属于无效的目标地址；客户端连接的时候也不能用这个IP，必须要指明连接哪个服务器IP】

③本机IP：网卡的真实IP地址，可用于局域网或公网通信，一般是DHCP自动分配

④localhost：不是IP地址，而是主机域名，但是默认解析后可以映射到127.0.0.1，属于人类可读的回环方式







